---
title: "BOJ 12147. Brattleship"

categories:
  - BaekJun
tags:
  - BaekJun

author_profile: false

sidebar:
  nav: "docs"

date: 2024-06-10
last_modified_at: 2024-06-10
---

# ğŸ™‡â€â™€ï¸[Silver III] Brattleship (Small) - 12147 

[ë¬¸ì œ ë§í¬](https://www.acmicpc.net/problem/12147) 

### ì„±ëŠ¥ ìš”ì•½

ë©”ëª¨ë¦¬: 2020 KB, ì‹œê°„: 0 ms

### ë¶„ë¥˜

ì• ë“œ í˜¹, ê¸°í•˜í•™, ìˆ˜í•™

### ì œì¶œ ì¼ì

2024ë…„ 6ì›” 10ì¼ 19:50:21

### ë¬¸ì œ ì„¤ëª…

<p>You're about to play a simplified "battleship" game with your little brother. The board for this game is a rectangular grid with <strong>R</strong> rows and <strong>C</strong> columns. At the start of the game, you will close your eyes, and you will keep them closed until the end of the game. Your little brother will take a single rectangular 1 x <strong>W</strong> ship and place it <strong>horizontally</strong> somewhere on the board. The ship must always fit entirely on the board, with each cell of the ship occupying exactly one of the grid's cells, and it can never be rotated.<br>
<br>
In each turn of the game, you name a cell on the board, and your little brother tells you whether that is a hit (one of the cells occupied by the ship) or a miss. (Your little brother doesn't say <em>which</em> part of the ship was hit -- just that the cell you named has a part of the ship in it.) You have perfect memory, and can keep track of all the information he has given you. Once you have named all of the cells occupied by the ship, the game is over (the ship is sunk), and your score is the number of turns taken. Your goal is to minimize your score.<br>
<br>
Although the ship is not supposed to be moved once it is placed, you know that your little brother, who is a brat, plans to cheat by changing the location of the ship whenever he wants, as long as the ship remains horizontal and completely on the board, and the new location is consistent with all the information he has given so far. For example, for a 1x4 board and 1x2 ship, your little brother could initially place the ship such that it overlaps the leftmost two columns. If your first guess was row 1, column 2, he could choose to secretly move the ship to the rightmost two columns, and tell you that (1, 2) was a miss. If your next guess after that was (1, 3), though, then he could not say that was also a miss and move the ship back to its original location, since that would be inconsistent with what he said about (1, 2) earlier.<br>
<br>
Not only do you know that your little brother will cheat, he knows that you know. If you both play optimally (you to minimize your score, him to maximize it), what is the lowest score that you can <strong>guarantee</strong> you will achieve, regardless of what your little brother does?</p>

### ì…ë ¥ 

 <p>The first line of the input gives the number of test cases, <strong>T</strong>. <strong>T</strong> lines follow, each with three space-separated integers <strong>R</strong>, <strong>C</strong>, and <strong>W</strong>: the number of rows and columns of the board, followed by the width of the ship.</p>

<h3>Limits</h3>

<ul>
	<li>1 â‰¤ <strong>W</strong> â‰¤ <strong>C</strong>.</li>
	<li><strong>T</strong> = 55.</li>
	<li><strong>R</strong> = 1.</li>
	<li>1 â‰¤ <strong>C</strong> â‰¤ 10.</li>
</ul>

### ì¶œë ¥ 

 <p>For each test case, output one line containing "Case #x: y", where x is the test case number (starting from 1) and y is the minimum score you can guarantee.</p>

## ğŸš€í’€ì´


- ë¬¸ì œ ì •ë¦¬
	- ë³´ë“œëŠ” R x C í¬ê¸°ì˜ ì§ì‚¬ê°í˜•ì…ë‹ˆë‹¤.
	- ë°°ëŠ” 1 x W í¬ê¸°ì˜ ìˆ˜í‰ ë°°ë¡œ ì£¼ì–´ì§‘ë‹ˆë‹¤.
	- ê²Œì„ì€ ì—¬ëŸ¬ ë¼ìš´ë“œë¡œ ì§„í–‰ë˜ë©°, ê° ë¼ìš´ë“œë§ˆë‹¤ ì£¼ì–´ì§„ ìœ„ì¹˜ê°€ ë°°ì˜ ì¼ë¶€ì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤.
	- ë°°ëŠ” ì ˆëŒ€ íšŒì „í•  ìˆ˜ ì—†ìœ¼ë©°, ë°°ì¹˜ê°€ ë™ìƒì˜ ì„ì˜ì ì¸ ìœ„ì¹˜ ë³€ê²½ìœ¼ë¡œ ì¸í•´ ìµœì ì˜ ê²½ìš°ë¡œ ì˜®ê²¨ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
	- ëª©í‘œëŠ” ìµœì†Œí•œì˜ ë¼ìš´ë“œ ìˆ˜ë¡œ ë°°ì˜ ìœ„ì¹˜ë¥¼ ì •í™•íˆ ì°¾ëŠ” ê²ƒì…ë‹ˆë‹¤.  


- í•´ê²° ì „ëµ
	- ê¸°ë³¸ ê°œë…: Rí–‰ Cì—´ì˜ ë³´ë“œì—ì„œ, ë°°ì˜ ê¸¸ì´ Wê°€ ì£¼ì–´ì§ˆ ë•Œ ìµœì•…ì˜ ê²½ìš°ë¥¼ ê³ ë ¤í•˜ì—¬ ìµœì†Œ ì¶”ì¸¡ íšŸìˆ˜ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.

- ìµœì ì˜ ì „ëµ:
	- ê° í–‰ì„ ë…ë¦½ì ìœ¼ë¡œ ìƒê°í•˜ì—¬ ê° í–‰ë§ˆë‹¤ ìµœì†Œí•œì˜ ì‹œë„ë¡œ ë°°ë¥¼ ì°¾ìŠµë‹ˆë‹¤.
	- ê° í–‰ì—ì„œì˜ ìµœì†Œ ì‹œë„ íšŸìˆ˜ëŠ” C // Wì…ë‹ˆë‹¤. ì´ ê°’ì€ ê° í–‰ì—ì„œ W ê¸¸ì´ì˜ ë°°ë¥¼ ì°¾ê¸° ìœ„í•´ í•„ìš”í•œ ìµœì†Œí•œì˜ ì‹œë„ì…ë‹ˆë‹¤.
	- ë°°ê°€ í¬í•¨ëœ ë§ˆì§€ë§‰ ìœ„ì¹˜ë¥¼ ì°¾ê¸° ìœ„í•´ ì¶”ê°€ì ì¸ W-1 ì‹œë„ê°€ í•„ìš”í•©ë‹ˆë‹¤.
	- ì—¬ëŸ¬ í–‰ì„ ê³ ë ¤í•˜ì—¬ ìµœì¢… ì ìˆ˜ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.

### ì„¤ëª… 
1. **ê¸°ë³¸ ì‹œë„ íšŸìˆ˜**: 
ê° í–‰ì—ì„œ `C / W`ë§Œí¼ì˜ ì‹œë„ íšŸìˆ˜ê°€ í•„ìš”í•©ë‹ˆë‹¤. ì´ëŠ” ê° í–‰ì—ì„œ ë°°ì˜ ìœ„ì¹˜ë¥¼ ì°¾ê¸° ìœ„í•´ í•„ìš”í•œ ìµœì†Œ ì‹œë„ íšŸìˆ˜ì…ë‹ˆë‹¤. 
2. **ì¶”ê°€ ì‹œë„ íšŸìˆ˜**: ë°°ì˜ ì •í™•í•œ ìœ„ì¹˜ë¥¼ ì°¾ê¸° ìœ„í•´ ë§ˆì§€ë§‰ìœ¼ë¡œ `W - 1`ë²ˆì˜ ì¶”ê°€ ì‹œë„ê°€ í•„ìš”í•©ë‹ˆë‹¤. 
3. **ìµœì¢… ì‹œë„ íšŸìˆ˜**: ëª¨ë“  í–‰ì— ëŒ€í•´ ê¸°ë³¸ ì‹œë„ íšŸìˆ˜ë¥¼ ê³„ì‚°í•œ í›„, ì¶”ê°€ ì‹œë„ íšŸìˆ˜ë¥¼ ë”í•˜ì—¬ ìµœì¢… ì‹œë„ íšŸìˆ˜ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤. 
4. **ì¶”ê°€ ì ê²€**: `C % W != 0`ì¼ ê²½ìš° í•œ ë²ˆ ë” ì‹œë„í•´ì•¼ í•©ë‹ˆë‹¤.

```cpp
void solve()
{
    int T;
    cin >> T;

    for (int t = 1; t <= T; ++t) 
    {
        int R, C, W;
        cin >> R >> C >> W;

        // ê° í–‰ë§ˆë‹¤ W ê¸¸ì´ì˜ ë°°ë¥¼ ì°¾ê¸° ìœ„í•´ í•„ìš”í•œ ìµœì†Œ ì‹œë„ íšŸìˆ˜
        int moves_per_row = C / W;

        // ë§ˆì§€ë§‰ ë¶€ë¶„ì—ì„œ ë°°ì˜ ìœ„ì¹˜ë¥¼ ì •í™•íˆ ì°¾ê¸° ìœ„í•´ W-1ë²ˆì˜ ì¶”ê°€ ì‹œë„ê°€ í•„ìš”
        int additional_moves = W - 1;

        // ëª¨ë“  í–‰ì—ì„œ ê¸°ë³¸ì ì¸ ì‹œë„ íšŸìˆ˜ë¥¼ ê³„ì‚°
        int total_moves = moves_per_row * R + additional_moves;

        // ë°°ê°€ ì •í™•íˆ Cì™€ ì¼ì¹˜í•˜ì§€ ì•Šì„ ê²½ìš°ë¥¼ ìœ„í•´ ì¶”ê°€ ì ê²€
        if (C % W != 0) 
        {
            total_moves += 1;
        }

        cout << "Case #" << t << ": " << total_moves << '\n';
    }
}
```

## ğŸš€ì½”ë“œ

```cpp
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include<iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <climits>

using namespace std;

void solve()
{
    int T;
    cin >> T;

    for (int t = 1; t <= T; ++t) 
    {
        int R, C, W;
        cin >> R >> C >> W;

        // ê° í–‰ë§ˆë‹¤ W ê¸¸ì´ì˜ ë°°ë¥¼ ì°¾ê¸° ìœ„í•´ í•„ìš”í•œ ìµœì†Œ ì‹œë„ íšŸìˆ˜
        int moves_per_row = C / W;

        // ë§ˆì§€ë§‰ ë¶€ë¶„ì—ì„œ ë°°ì˜ ìœ„ì¹˜ë¥¼ ì •í™•íˆ ì°¾ê¸° ìœ„í•´ W-1ë²ˆì˜ ì¶”ê°€ ì‹œë„ê°€ í•„ìš”
        int additional_moves = W - 1;

        // ëª¨ë“  í–‰ì—ì„œ ê¸°ë³¸ì ì¸ ì‹œë„ íšŸìˆ˜ë¥¼ ê³„ì‚°
        int total_moves = moves_per_row * R + additional_moves;

        // ë°°ê°€ ì •í™•íˆ Cì™€ ì¼ì¹˜í•˜ì§€ ì•Šì„ ê²½ìš°ë¥¼ ìœ„í•´ ì¶”ê°€ ì ê²€
        if (C % W != 0) 
        {
            total_moves += 1;
        }

        cout << "Case #" << t << ": " << total_moves << '\n';
    }
}

int main()
{
	FILE* stream;
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	freopen_s(&stream, "input.txt", "rt", stdin);

	solve();

	return 0;
}
```
---
title: "BOJ 14500. 테트로미노"

categories:
  - BaekJun
tags:
  - BaekJun

author_profile: false

sidebar:
  nav: "docs"

date: 2024-01-12
last_modified_at: 2024-01-12
---

# [Gold IV] 테트로미노 - 14500 

[문제 링크](https://www.acmicpc.net/problem/14500) 

### 성능 요약

메모리: 2948 KB, 시간: 20 ms

### 분류

브루트포스 알고리즘, 구현

### 제출 일자

2024년 1월 12일 17:20:59

### 문제 설명

<p>폴리오미노란 크기가 1×1인 정사각형을 여러 개 이어서 붙인 도형이며, 다음과 같은 조건을 만족해야 한다.</p>

<ul>
	<li>정사각형은 서로 겹치면 안 된다.</li>
	<li>도형은 모두 연결되어 있어야 한다.</li>
	<li>정사각형의 변끼리 연결되어 있어야 한다. 즉, 꼭짓점과 꼭짓점만 맞닿아 있으면 안 된다.</li>
</ul>

<p>정사각형 4개를 이어 붙인 폴리오미노는 테트로미노라고 하며, 다음과 같은 5가지가 있다.</p>

<p style="text-align:center"><a href="https://commons.wikimedia.org/wiki/File:All_5_free_tetrominoes.svg"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14500/1.png" style="height:167px; width:250px"></a></p>

<p>아름이는 크기가 N×M인 종이 위에 테트로미노 하나를 놓으려고 한다. 종이는 1×1 크기의 칸으로 나누어져 있으며, 각각의 칸에는 정수가 하나 쓰여 있다.</p>

<p>테트로미노 하나를 적절히 놓아서 테트로미노가 놓인 칸에 쓰여 있는 수들의 합을 최대로 하는 프로그램을 작성하시오.</p>

<p>테트로미노는 반드시 한 정사각형이 정확히 하나의 칸을 포함하도록 놓아야 하며, 회전이나 대칭을 시켜도 된다.</p>

### 입력 

 <p>첫째 줄에 종이의 세로 크기 N과 가로 크기 M이 주어진다. (4 ≤ N, M ≤ 500)</p>

<p>둘째 줄부터 N개의 줄에 종이에 쓰여 있는 수가 주어진다. i번째 줄의 j번째 수는 위에서부터 i번째 칸, 왼쪽에서부터 j번째 칸에 쓰여 있는 수이다. 입력으로 주어지는 수는 1,000을 넘지 않는 자연수이다.</p>

### 출력 

 <p>첫째 줄에 테트로미노가 놓인 칸에 쓰인 수들의 합의 최댓값을 출력한다.</p>

## 🚀풀이

이게 정석적인 풀이가 맞는지는 모르겠는데 난 노가다로 풀었다.  

테트로미노의 모든 경우의 수를 다 대입해서 최대값을 구했다...  

솔직히 좋은 방법이 생각이 안나서 아몰라하고 풀었는데...  

시간제한이 안뜨고 통과됐다...  

```cpp
int n, m, res = 0;
vector<vector<int>> board;
void solve()
{
	cin >> n >> m;
	board = vector<vector<int>>(n + 1, vector<int>(m + 1));

	for (int y = 1; y <= n; ++y)
	{
		for (int x = 1; x <= m; ++x)
		{
			cin >> board[y][x];
		}
	}

	// ㅡ 
	for (int y = 1; y <= n; ++y)
	{
		for (int x = 1; x <= m - 3; ++x)
		{
			int temp = 0;
			temp += board[y][x];
			temp += board[y][x + 1];
			temp += board[y][x + 2];
			temp += board[y][x + 3];

			res = max(res, temp);
		}
	}

	// ㅣ 
	for (int y = 1; y <= n - 3; ++y)
	{
		for (int x = 1; x <= m; ++x)
		{
			int temp = 0;
			temp += board[y + 0][x];
			temp += board[y + 1][x];
			temp += board[y + 2][x];
			temp += board[y + 3][x];

			res = max(res, temp);
		}
	}

	// ㅁ 
	for (int y = 1; y <= n - 1; ++y)
	{
		for (int x = 1; x <= m - 1; ++x)
		{
			int temp = 0;
			temp += board[y + 0][x + 0];
			temp += board[y + 0][x + 1];
			temp += board[y + 1][x + 0];
			temp += board[y + 1][x + 1];

			res = max(res, temp);
		}
	}

	// L 
	for (int y = 1; y <= n - 2; ++y)
	{
		for (int x = 1; x <= m - 1; ++x)
		{
			int temp = 0;
			temp += board[y][x];
			temp += board[y + 1][x];
			temp += board[y + 2][x];
			temp += board[y + 2][x + 1];

			res = max(res, temp);
		}
	}

	// L 대칭
	for (int y = 1; y <= n - 2; ++y)
	{
		for (int x = 1; x <= m - 1; ++x)
		{
			int temp = 0;
			temp += board[y + 0][x + 1];
			temp += board[y + 1][x + 1];
			temp += board[y + 2][x + 1];
			temp += board[y + 2][x + 0];

			res = max(res, temp);
		}
	}

	// ㄴ
	for (int y = 1; y <= n - 1; ++y)
	{
		for (int x = 1; x <= m - 2; ++x)
		{
			int temp = 0;
			temp += board[y][x];
			temp += board[y + 1][x];
			temp += board[y + 1][x + 1];
			temp += board[y + 1][x + 2];

			res = max(res, temp);
		}
	}

	// ㄴ 뒤집은거
	for (int y = 2; y <= n; ++y)
	{
		for (int x = 1; x <= m - 2; ++x)
		{
			int temp = 0;
			for (int k = 0; k < 3; ++k)
			{
				temp += board[y][x + k];
			}
			temp += board[y - 1][x + 2];

			res = max(res, temp);
		}
	}

	// ㄱ
	for (int y = 1; y <= n - 1; ++y)
	{
		for (int x = 1; x <= m - 2; ++x)
		{
			int temp = 0;
			temp += board[y][x];
			temp += board[y][x + 1];
			temp += board[y][x + 2];
			temp += board[y + 1][x + 2];

			res = max(res, temp);
		}
	}

	// ㄱ 뒤집은거
	for (int y = 1; y <= n - 1; ++y)
	{
		for (int x = 1; x <= m - 2; ++x)
		{
			int temp = 0;
			for (int k = 0; k < 3; ++k)
			{
				temp += board[y][x + k];
			}
			temp += board[y + 1][x];

			res = max(res, temp);
		}
	}

	// 긴 ㄱ
	for (int y = 1; y <= n - 2; ++y)
	{
		for (int x = 1; x <= m - 1; ++x)
		{
			int temp = 0;
			temp += board[y][x];
			temp += board[y][x + 1];
			temp += board[y + 1][x + 1];
			temp += board[y + 2][x + 1];

			res = max(res, temp);
		}
	}

	// 긴 ㄱ 대칭
	for (int y = 1; y <= n - 2; ++y)
	{
		for (int x = 1; x <= m - 1; ++x)
		{
			int temp = 0;
			temp += board[y][x];
			temp += board[y][x + 1];
			temp += board[y + 1][x];
			temp += board[y + 2][x];

			res = max(res, temp);
		}
	}

	// ㄹ 시리즈 1
	for (int y = 1; y <= n - 2; ++y)
	{
		for (int x = 1; x <= m - 1; ++x)
		{
			int temp = 0;
			temp += board[y][x];
			temp += board[y + 1][x];
			temp += board[y + 1][x + 1];
			temp += board[y + 2][x + 1];

			res = max(res, temp);
		}
	}

	// ㄹ 시리즈 1
	for (int y = 1; y <= n - 2; ++y)
	{
		for (int x = 1; x <= m - 1; ++x)
		{
			int temp = 0;
			temp += board[y][x + 1];
			temp += board[y + 1][x + 1];
			temp += board[y + 1][x];
			temp += board[y + 2][x];

			res = max(res, temp);
		}
	}

	// ㄹ 시리즈 2
	for (int y = 1; y <= n - 1; ++y)
	{
		for (int x = 1; x <= m - 2; ++x)
		{
			int temp = 0;
			temp += board[y + 1][x];
			temp += board[y + 1][x + 1];
			temp += board[y][x + 1];
			temp += board[y][x + 2];

			res = max(res, temp);
		}
	}

	// ㄹ 시리즈 2 대칭
	for (int y = 1; y <= n - 1; ++y)
	{
		for (int x = 1; x <= m - 2; ++x)
		{
			int temp = 0;
			temp += board[y][x];
			temp += board[y][x + 1];
			temp += board[y + 1][x + 1];
			temp += board[y + 1][x + 2];

			res = max(res, temp);
		}
	}

	// ㅏ
	for (int y = 1; y <= n - 2; ++y)
	{
		for (int x = 1; x <= m - 1; ++x)
		{
			int temp = 0;
			temp += board[y][x];
			temp += board[y + 1][x];
			temp += board[y + 1][x + 1];
			temp += board[y + 2][x];

			res = max(res, temp);
		}
	}

	// ㅜ
	for (int y = 1; y <= n - 1; ++y)
	{
		for (int x = 1; x <= m - 2; ++x)
		{
			int temp = 0;
			temp += board[y][x];
			temp += board[y][x + 1];
			temp += board[y][x + 2];
			temp += board[y + 1][x + 1];

			res = max(res, temp);
		}
	}

	// ㅓ
	for (int y = 1; y <= n - 2; ++y)
	{
		for (int x = 1; x <= m - 1; ++x)
		{
			int temp = 0;
			temp += board[y + 1][x];
			temp += board[y][x + 1];
			temp += board[y + 1][x + 1];
			temp += board[y + 2][x + 1];

			res = max(res, temp);
		}
	}

	// ㅗ
	for (int y = 1; y <= n - 1; ++y)
	{
		for (int x = 1; x <= m - 2; ++x)
		{
			int temp = 0;
			temp += board[y][x + 1];
			temp += board[y + 1][x];
			temp += board[y + 1][x + 1];
			temp += board[y + 1][x + 2];

			res = max(res, temp);
		}
	}

	cout << res;
}
```

모든 경우를 다 탐색한 코드다...  

다른 사람들 코드를 좀 보고 생각을 더 해야겠다.  

## 🚀전체 코드

```cpp
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include<iostream>
#include <fstream>
#include <vector>
#include <algorithm>

using namespace std;

int n, m, res = 0;
vector<vector<int>> board;
void solve()
{
	cin >> n >> m;
	board = vector<vector<int>>(n + 1, vector<int>(m + 1));

	for (int y = 1; y <= n; ++y)
	{
		for (int x = 1; x <= m; ++x)
		{
			cin >> board[y][x];
		}
	}

	// ㅡ 
	for (int y = 1; y <= n; ++y)
	{
		for (int x = 1; x <= m - 3; ++x)
		{
			int temp = 0;
			temp += board[y][x];
			temp += board[y][x + 1];
			temp += board[y][x + 2];
			temp += board[y][x + 3];

			res = max(res, temp);
		}
	}

	// ㅣ 
	for (int y = 1; y <= n - 3; ++y)
	{
		for (int x = 1; x <= m; ++x)
		{
			int temp = 0;
			temp += board[y + 0][x];
			temp += board[y + 1][x];
			temp += board[y + 2][x];
			temp += board[y + 3][x];

			res = max(res, temp);
		}
	}

	// ㅁ 
	for (int y = 1; y <= n - 1; ++y)
	{
		for (int x = 1; x <= m - 1; ++x)
		{
			int temp = 0;
			temp += board[y + 0][x + 0];
			temp += board[y + 0][x + 1];
			temp += board[y + 1][x + 0];
			temp += board[y + 1][x + 1];

			res = max(res, temp);
		}
	}

	// L 
	for (int y = 1; y <= n - 2; ++y)
	{
		for (int x = 1; x <= m - 1; ++x)
		{
			int temp = 0;
			temp += board[y][x];
			temp += board[y + 1][x];
			temp += board[y + 2][x];
			temp += board[y + 2][x + 1];

			res = max(res, temp);
		}
	}

	// L 대칭
	for (int y = 1; y <= n - 2; ++y)
	{
		for (int x = 1; x <= m - 1; ++x)
		{
			int temp = 0;
			temp += board[y + 0][x + 1];
			temp += board[y + 1][x + 1];
			temp += board[y + 2][x + 1];
			temp += board[y + 2][x + 0];

			res = max(res, temp);
		}
	}

	// ㄴ
	for (int y = 1; y <= n - 1; ++y)
	{
		for (int x = 1; x <= m - 2; ++x)
		{
			int temp = 0;
			temp += board[y][x];
			temp += board[y + 1][x];
			temp += board[y + 1][x + 1];
			temp += board[y + 1][x + 2];

			res = max(res, temp);
		}
	}

	// ㄴ 뒤집은거
	for (int y = 2; y <= n; ++y)
	{
		for (int x = 1; x <= m - 2; ++x)
		{
			int temp = 0;
			for (int k = 0; k < 3; ++k)
			{
				temp += board[y][x + k];
			}
			temp += board[y - 1][x + 2];

			res = max(res, temp);
		}
	}

	// ㄱ
	for (int y = 1; y <= n - 1; ++y)
	{
		for (int x = 1; x <= m - 2; ++x)
		{
			int temp = 0;
			temp += board[y][x];
			temp += board[y][x + 1];
			temp += board[y][x + 2];
			temp += board[y + 1][x + 2];

			res = max(res, temp);
		}
	}

	// ㄱ 뒤집은거
	for (int y = 1; y <= n - 1; ++y)
	{
		for (int x = 1; x <= m - 2; ++x)
		{
			int temp = 0;
			for (int k = 0; k < 3; ++k)
			{
				temp += board[y][x + k];
			}
			temp += board[y + 1][x];

			res = max(res, temp);
		}
	}

	// 긴 ㄱ
	for (int y = 1; y <= n - 2; ++y)
	{
		for (int x = 1; x <= m - 1; ++x)
		{
			int temp = 0;
			temp += board[y][x];
			temp += board[y][x + 1];
			temp += board[y + 1][x + 1];
			temp += board[y + 2][x + 1];

			res = max(res, temp);
		}
	}

	// 긴 ㄱ 대칭
	for (int y = 1; y <= n - 2; ++y)
	{
		for (int x = 1; x <= m - 1; ++x)
		{
			int temp = 0;
			temp += board[y][x];
			temp += board[y][x + 1];
			temp += board[y + 1][x];
			temp += board[y + 2][x];

			res = max(res, temp);
		}
	}

	// ㄹ 시리즈 1
	for (int y = 1; y <= n - 2; ++y)
	{
		for (int x = 1; x <= m - 1; ++x)
		{
			int temp = 0;
			temp += board[y][x];
			temp += board[y + 1][x];
			temp += board[y + 1][x + 1];
			temp += board[y + 2][x + 1];

			res = max(res, temp);
		}
	}

	// ㄹ 시리즈 1
	for (int y = 1; y <= n - 2; ++y)
	{
		for (int x = 1; x <= m - 1; ++x)
		{
			int temp = 0;
			temp += board[y][x + 1];
			temp += board[y + 1][x + 1];
			temp += board[y + 1][x];
			temp += board[y + 2][x];

			res = max(res, temp);
		}
	}

	// ㄹ 시리즈 2
	for (int y = 1; y <= n - 1; ++y)
	{
		for (int x = 1; x <= m - 2; ++x)
		{
			int temp = 0;
			temp += board[y + 1][x];
			temp += board[y + 1][x + 1];
			temp += board[y][x + 1];
			temp += board[y][x + 2];

			res = max(res, temp);
		}
	}

	// ㄹ 시리즈 2 대칭
	for (int y = 1; y <= n - 1; ++y)
	{
		for (int x = 1; x <= m - 2; ++x)
		{
			int temp = 0;
			temp += board[y][x];
			temp += board[y][x + 1];
			temp += board[y + 1][x + 1];
			temp += board[y + 1][x + 2];

			res = max(res, temp);
		}
	}

	// ㅏ
	for (int y = 1; y <= n - 2; ++y)
	{
		for (int x = 1; x <= m - 1; ++x)
		{
			int temp = 0;
			temp += board[y][x];
			temp += board[y + 1][x];
			temp += board[y + 1][x + 1];
			temp += board[y + 2][x];

			res = max(res, temp);
		}
	}

	// ㅜ
	for (int y = 1; y <= n - 1; ++y)
	{
		for (int x = 1; x <= m - 2; ++x)
		{
			int temp = 0;
			temp += board[y][x];
			temp += board[y][x + 1];
			temp += board[y][x + 2];
			temp += board[y + 1][x + 1];

			res = max(res, temp);
		}
	}

	// ㅓ
	for (int y = 1; y <= n - 2; ++y)
	{
		for (int x = 1; x <= m - 1; ++x)
		{
			int temp = 0;
			temp += board[y + 1][x];
			temp += board[y][x + 1];
			temp += board[y + 1][x + 1];
			temp += board[y + 2][x + 1];

			res = max(res, temp);
		}
	}

	// ㅗ
	for (int y = 1; y <= n - 1; ++y)
	{
		for (int x = 1; x <= m - 2; ++x)
		{
			int temp = 0;
			temp += board[y][x + 1];
			temp += board[y + 1][x];
			temp += board[y + 1][x + 1];
			temp += board[y + 1][x + 2];

			res = max(res, temp);
		}
	}

	cout << res;
}

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	freopen("input.txt", "rt", stdin);

	solve();

	return 0;
}
```
---
title: "it ì·¨ì—…ì„ ìœ„í•œ ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œí’€ì´ ì…ë¬¸ : 47. ë´‰ìš°ë¦¬"

categories:
  - BaekJun
tags:
  - BaekJun

author_profile: false

sidebar:
  nav: "docs"

date: 2023-12-17
last_modified_at: 2023-12-17
---

# ğŸ™‡â€â™€ï¸ë´‰ìš°ë¦¬

ì§€ë„ ì •ë³´ê°€ N*N ê²©ìíŒì— ì£¼ì–´ì§‘ë‹ˆë‹¤. ê° ê²©ìì—ëŠ” ê·¸ ì§€ì—­ì˜ ë†’ì´ê°€ ì“°ì—¬ìˆìŠµë‹ˆë‹¤.  

ê° ê²©ìíŒì˜ ìˆ«ì ì¤‘ ìì‹ ì˜ ìƒí•˜ì¢Œìš° ìˆ«ìë³´ë‹¤ í° ìˆ«ìëŠ” ë´‰ìš°ë¦¬ ì§€ì—­ì…ë‹ˆë‹¤.  

ë´‰ìš°ë¦¬ ì§€ì—­ì´ ëª‡ ê°œ ìˆëŠ” ì§€ ì•Œì•„ë‚´ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì„¸ìš”.  

ê²©ìì˜ ê°€ì¥ìë¦¬ëŠ” 0ìœ¼ë¡œ ì´ˆê¸°í™” ë˜ì—ˆë‹¤ê³  ê°€ì •í•œë‹¤.  

ë§Œì•½ N=5 ì´ê³ , ê²©ìíŒì˜ ìˆ«ìê°€ ë‹¤ìŒê³¼ ê°™ë‹¤ë©´ ë´‰ìš°ë¦¬ì˜ ê°œìˆ˜ëŠ” 10ê°œì…ë‹ˆë‹¤.  

![ìŠ¤í¬ë¦°ìƒ· 2023-12-17 013101](https://github.com/stopresent/BOJ/assets/86364202/43f960d3-91b9-4dbd-ae60-883833f0a183)

```
â–£ ì…ë ¥ì„¤ëª…
ì²« ì¤„ì— ìì—°ìˆ˜ Nì´ ì£¼ì–´ì§„ë‹¤.(1<=N<=50)  

ë‘ ë²ˆì§¸ ì¤„ë¶€í„° Nì¤„ì— ê±¸ì³ ê° ì¤„ì— Nê°œì˜ ìì—°ìˆ˜ê°€ ì£¼ì–´ì§„ë‹¤.  
ê° ìì—°ìˆ˜ëŠ” 100ì„ ë„˜ì§€ ì•ŠëŠ”ë‹¤. 

â–£ ì¶œë ¥ì„¤ëª…
ë´‰ìš°ë¦¬ì˜ ê°œìˆ˜ë¥¼ ì¶œë ¥í•˜ì„¸ìš”.

â–£ ì…ë ¥ì˜ˆì œ 1 
5
5 3 7 2 3
3 7 1 6 1
7 2 5 3 4
4 3 6 4 1
8 7 3 5 2

â–£ ì¶œë ¥ì˜ˆì œ 1
10
```

## ğŸš€í’€ì´

ì „í˜•ì ì¸ ì™„ì „ íƒìƒ‰ ë¬¸ì œì²˜ëŸ¼ ë³´ì˜€ë‹¤.  

Nì˜ ìˆ˜ê°€ ì‘ì•„ì„œ ëª¨ë“  ê²½ìš°ë¥¼ íƒìƒ‰í•˜ì—¬ ë¬¸ì œë¥¼ í’€ì—ˆë‹¤.  

ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.  

```cpp
int N;
vector<vector<int>> board;

struct Pos
{
	bool operator==(Pos& other)
	{
		return y == other.y && x == other.x;
	}

	bool operator!=(Pos& other)
	{
		return !(*this == other);
	}

	bool operator<(const Pos& other) const
	{
		if (y != other.y)
			return y < other.y;
		return x < other.x;
	}

	Pos operator+(Pos& other)
	{
		Pos ret;
		ret.y = y + other.y;
		ret.x = x + other.x;
		return ret;
	}

	Pos& operator+=(Pos& other)
	{
		y += other.y;
		x += other.x;
		return *this;
	}

	int y;
	int x;
};

Pos front[4] =
{
	Pos { -1, 0}, // UP
	Pos { 0, -1}, // LEFT
	Pos { 1, 0},  // DOWN
	Pos { 0, 1},  // RIGHT
};

bool IsInside(Pos pos)
{
	if (pos.y < 0 || pos.x < 0)
		return false;
	if (pos.y > N - 1 || pos.x > N - 1)
		return false;

	return true;
}

void solve()
{
	cin >> N;
	board = vector<vector<int>>(N, vector<int>(N));

	for (int y = 0; y < N; ++y)
	{
		for (int x = 0; x < N; ++x)
		{
			cin >> board[y][x];
		}
	}

	int cnt = 0;
	for (int y = 0; y < N; ++y)
	{
		for (int x = 0; x < N; ++x)
		{
			Pos pos = { y ,x };
			bool flag = false;
			for (int dir = 0; dir < 4; ++dir)
			{
				Pos nextPos = pos + front[dir];

				if (IsInside(nextPos) && board[nextPos.y][nextPos.x] < board[y][x])
				{
					flag = true;
				}
				else if (IsInside(nextPos) && board[nextPos.y][nextPos.x] >= board[y][x])
				{
					flag = false;
					break;
				}
				
				if (IsInside(nextPos))
					flag = flag;
			}

			if (flag == true)
			{
				cnt++;
				//cout << "pos.y : " << pos.y << "  pos.x : " << pos.x << endl;
			}
		}
	}

	cout << cnt;
}
```

## ğŸš€ì „ì²´ ì½”ë“œ

```cpp
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include<iostream>
#include <fstream>
#include <vector>
#include <algorithm>

using namespace std;

int N;
vector<vector<int>> board;

struct Pos
{
	bool operator==(Pos& other)
	{
		return y == other.y && x == other.x;
	}

	bool operator!=(Pos& other)
	{
		return !(*this == other);
	}

	bool operator<(const Pos& other) const
	{
		if (y != other.y)
			return y < other.y;
		return x < other.x;
	}

	Pos operator+(Pos& other)
	{
		Pos ret;
		ret.y = y + other.y;
		ret.x = x + other.x;
		return ret;
	}

	Pos& operator+=(Pos& other)
	{
		y += other.y;
		x += other.x;
		return *this;
	}

	int y;
	int x;
};

Pos front[4] =
{
	Pos { -1, 0}, // UP
	Pos { 0, -1}, // LEFT
	Pos { 1, 0},  // DOWN
	Pos { 0, 1},  // RIGHT
};

bool IsInside(Pos pos)
{
	if (pos.y < 0 || pos.x < 0)
		return false;
	if (pos.y > N - 1 || pos.x > N - 1)
		return false;

	return true;
}

void solve()
{
	cin >> N;
	board = vector<vector<int>>(N, vector<int>(N));

	for (int y = 0; y < N; ++y)
	{
		for (int x = 0; x < N; ++x)
		{
			cin >> board[y][x];
		}
	}

	int cnt = 0;
	for (int y = 0; y < N; ++y)
	{
		for (int x = 0; x < N; ++x)
		{
			Pos pos = { y ,x };
			bool flag = false;
			for (int dir = 0; dir < 4; ++dir)
			{
				Pos nextPos = pos + front[dir];

				if (IsInside(nextPos) && board[nextPos.y][nextPos.x] < board[y][x])
				{
					flag = true;
				}
				else if (IsInside(nextPos) && board[nextPos.y][nextPos.x] >= board[y][x])
				{
					flag = false;
					break;
				}
				
				if (IsInside(nextPos))
					flag = flag;
			}

			if (flag == true)
			{
				cnt++;
				//cout << "pos.y : " << pos.y << "  pos.x : " << pos.x << endl;
			}
		}
	}

	cout << cnt;
}

int main() 
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	//freopen("input.txt", "rt", stdin);

	solve();

	return 0;
}
```
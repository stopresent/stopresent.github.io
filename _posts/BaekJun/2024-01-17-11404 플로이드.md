---
title: "BOJ 11404. 플로이드"

categories:
  - BaekJun
tags:
  - BaekJun

author_profile: false

sidebar:
  nav: "docs"

date: 2024-01-17
last_modified_at: 2024-01-17
---

# 🙇‍♀️[Gold IV] 플로이드 - 11404 

[문제 링크](https://www.acmicpc.net/problem/11404) 

### 성능 요약

메모리: 2152 KB, 시간: 24 ms

### 분류

플로이드–워셜, 그래프 이론, 최단 경로

### 제출 일자

2024년 1월 17일 13:34:02

### 문제 설명

<p>n(2 ≤ n ≤ 100)개의 도시가 있다. 그리고 한 도시에서 출발하여 다른 도시에 도착하는 m(1 ≤ m ≤ 100,000)개의 버스가 있다. 각 버스는 한 번 사용할 때 필요한 비용이 있다.</p>

<p>모든 도시의 쌍 (A, B)에 대해서 도시 A에서 B로 가는데 필요한 비용의 최솟값을 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 도시의 개수 n이 주어지고 둘째 줄에는 버스의 개수 m이 주어진다. 그리고 셋째 줄부터 m+2줄까지 다음과 같은 버스의 정보가 주어진다. 먼저 처음에는 그 버스의 출발 도시의 번호가 주어진다. 버스의 정보는 버스의 시작 도시 a, 도착 도시 b, 한 번 타는데 필요한 비용 c로 이루어져 있다. 시작 도시와 도착 도시가 같은 경우는 없다. 비용은 100,000보다 작거나 같은 자연수이다.</p>

<p>시작 도시와 도착 도시를 연결하는 노선은 하나가 아닐 수 있다.</p>

### 출력 

 <p>n개의 줄을 출력해야 한다. i번째 줄에 출력하는 j번째 숫자는 도시 i에서 j로 가는데 필요한 최소 비용이다. 만약, i에서 j로 갈 수 없는 경우에는 그 자리에 0을 출력한다.</p>

## 🚀풀이

플로이드-워샬 알고리즘 문제이다.  

i에서 j로 가능 경로가 여러개로 나오기 때문에 최단 거리만 기록해야한다.  

```cpp
int n, m, INF = 123456789;
vector<vector<int> > dis;
void setting()
{
	cin >> n >> m;
	dis = vector<vector<int>>(n + 1, vector<int>(n + 1, INF));

	for (int i = 1; i <= n; ++i)
	{
		dis[i][i] = 0;
	}

	int a, b, c;
	for (int i = 1; i <= m; ++i)
	{
		cin >> a >> b >> c;
		if (dis[a][b] == INF)
		{
			dis[a][b] = c;
		}
		else if (dis[a][b] != INF && c < dis[a][b])
		{
			dis[a][b] = c;
		}
	}
}
```
자기 자신까지 가는 거리는 0으로 초기화해야한다.  

플로이드-워샬 알고리즘은 3중 for문을 이용한다.  
`if (dis[i][j] > dis[i][k] + dis[k][j])`  
이 말이 다른 경로를 경유해서 가는 경우가 비용이 덜 드는 경우이다.  
```cpp
void solve()
{
    // 플로이드 워샬 핵심!
	for (int k = 1; k <= n; ++k)
		for (int i = 1; i <= n; ++i)
			for (int j = 1; j <= n; ++j)
			{
				if (dis[i][j] > dis[i][k] + dis[k][j])
				{
					dis[i][j] = dis[i][k] + dis[k][j];
				}
			}


	for (int i = 1; i <= n; ++i)
	{
		for (int j = 1; j <= n; ++j)
		{
            // 가는 방법이 없는 경우
			if (dis[i][j] == INF)
				cout << 0 << " ";
			else
				cout << dis[i][j] << " ";
		}
		cout << '\n';
	}
}
```

**i에서 j로 가는 기본 연결 정보**

|1|2|3|4|5|
|---|---|---|---|---|
|0| 2| 3| 1| 10|
|INF| 0| INF| 2| INF|
|8| INF| 0| 1| 1|
|INF| INF| INF| 0| 3|
|7| 4| INF| INF| 0|  

---

**dis[3][2]에서 업데이트 발생 기존의 값 : 123456789**  
dis[3][2]에서 업데이트 결과  
dis[3][2] = dis[3][1] + dis[1][2]  
10 = 8 + 2  

|1|2|3|4|5|
|---|---|---|---|---|
|0| 2| 3| 1| 10|
|INF| 0| INF| 2| INF|
|8| 10| 0| 1| 1|
|INF| INF| INF| 0| 3|
|7| 4| INF| INF| 0|

**dis[5][3]에서 업데이트 발생 기존의 값 : 123456789**  
dis[5][3]에서 업데이트 결과  
dis[5][3] = dis[5][1] + dis[1][3]  
10 = 7 + 3  

|1|2|3|4|5|
|---|---|---|---|---|
|0| 2| 3| 1| 10|
|INF| 0| INF| 2| INF|
|8| 10| 0| 1| 1|
|INF| INF| INF| 0| 3|
|7| 4| 10| INF| 0|

**dis[5][4]에서 업데이트 발생 기존의 값 : 123456789**  
dis[5][4]에서 업데이트 결과  
dis[5][4] = dis[5][1] + dis[1][4]  
8 = 7 + 1  

|1|2|3|4|5|
|---|---|---|---|---|
|0| 2| 3| 1| 10|
|INF| 0| INF| 2| INF|
|8| 10| 0| 1| 1|
|INF| INF| INF| 0| 3|
|7| 4| 10| 8| 0|

**dis[5][4]에서 업데이트 발생 기존의 값 : 8**  
dis[5][4]에서 업데이트 결과  
dis[5][4] = dis[5][2] + dis[2][4]  
6 = 4 + 2  

|1|2|3|4|5|
|---|---|---|---|---|
|0| 2| 3| 1| 10|
|INF| 0| INF| 2| INF|
|8| 10| 0| 1| 1|
|INF| INF| INF| 0| 3|
|7| 4| 10| 6| 0|

**dis[1][5]에서 업데이트 발생 기존의 값 : 10**  
dis[1][5]에서 업데이트 결과  
dis[1][5] = dis[1][3] + dis[3][5]  
4 = 3 + 1  

|1|2|3|4|5|
|---|---|---|---|---|
|0| 2| 3| 1| 4|
|INF| 0| INF| 2| INF|
|8| 10| 0| 1| 1|
|INF| INF| INF| 0| 3|
|7| 4| 10| 6| 0|


**dis[2][5]에서 업데이트 발생 기존의 값 : 123456789**  
dis[2][5]에서 업데이트 결과  
dis[2][5] = dis[2][4] + dis[4][5]  
5 = 2 + 3  

|1|2|3|4|5|
|---|---|---|---|---|
|0| 2| 3| 1| 4|
|INF| 0| INF| 2| 5|
|8| 10| 0| 1| 1|
|INF| INF| INF| 0| 3|
|7| 4| 10| 6| 0|

**dis[2][1]에서 업데이트 발생 기존의 값 : 123456789**  
dis[2][1]에서 업데이트 결과  
dis[2][1] = dis[2][5] + dis[5][1]  
12 = 5 + 7  

|1|2|3|4|5|
|---|---|---|---|---|
|0| 2| 3| 1| 4|
|12| 0| INF| 2| 5|
|8| 10| 0| 1| 1|
|INF| INF| INF| 0| 3|
|7| 4| 10| 6| 0|


**dis[2][3]에서 업데이트 발생 기존의 값 : 123456789**  
dis[2][3]에서 업데이트 결과  
dis[2][3] = dis[2][5] + dis[5][3]  
15 = 5 + 10  

|1|2|3|4|5|
|---|---|---|---|---|
|0| 2| 3| 1| 4|
|12| 0| 15| 2| 5|
|8| 10| 0| 1| 1|
|INF| INF| INF| 0| 3|
|7| 4| 10| 6| 0|

**dis[3][2]에서 업데이트 발생 기존의 값 : 10**  
dis[3][2]에서 업데이트 결과  
dis[3][2] = dis[3][5] + dis[5][2]  
5 = 1 + 4  

|1|2|3|4|5|
|---|---|---|---|---|
|0| 2| 3| 1| 4|
|12| 0| 15| 2| 5|
|8| 5| 0| 1| 1|
|INF| INF| INF| 0| 3|
|7| 4| 10| 6| 0|

**dis[4][1]에서 업데이트 발생 기존의 값 : 123456789**  
dis[4][1]에서 업데이트 결과  
dis[4][1] = dis[4][5] + dis[5][1]  
10 = 3 + 7  

|1|2|3|4|5|
|---|---|---|---|---|
|0| 2| 3| 1| 4|
|12| 0| 15| 2| 5|
|8| 5| 0| 1| 1|
|10| INF| INF| 0| 3|
|7| 4| 10| 6| 0|


**dis[4][2]에서 업데이트 발생 기존의 값 : 123456789**  
dis[4][2]에서 업데이트 결과  
dis[4][2] = dis[4][5] + dis[5][2]  
7 = 3 + 4  

|1|2|3|4|5|
|---|---|---|---|---|
|0| 2| 3| 1| 4|
|12| 0| 15| 2| 5|
|8| 5| 0| 1| 1|
|10| 7| INF| 0| 3|
|7| 4| 10| 6| 0|


**dis[4][3]에서 업데이트 발생 기존의 값 : 123456789**  
dis[4][3]에서 업데이트 결과  
dis[4][3] = dis[4][5] + dis[5][3]  
13 = 3 + 10  

|1|2|3|4|5|
|---|---|---|---|---|
|0| 2| 3| 1| 4|
|12| 0| 15| 2| 5|
|8| 5| 0| 1| 1|
|10| 7| 13| 0| 3|
|7| 4| 10| 6| 0|


---

**결과**
```
0 2 3 1 4
12 0 15 2 5
8 5 0 1 1
10 7 13 0 3
7 4 10 6 0
```

## 🚀전체 코드

```cpp
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include<iostream>
#include <fstream>
#include <vector>
#include <algorithm>

using namespace std;

int n, m, INF = 123456789;
vector<vector<int> > dis;
void setting()
{
	cin >> n >> m;
	dis = vector<vector<int>>(n + 1, vector<int>(n + 1, INF));

	for (int i = 1; i <= n; ++i)
	{
		dis[i][i] = 0;
	}

	int a, b, c;
	for (int i = 1; i <= m; ++i)
	{
		cin >> a >> b >> c;
		if (dis[a][b] == INF)
		{
			dis[a][b] = c;
		}
		else if (dis[a][b] != INF && c < dis[a][b])
		{
			dis[a][b] = c;
		}
	}

	//for (int i = 1; i <= n; ++i)
	//{
	//	for (int j = 1; j <= n; ++j)
	//	{
	//		cout << dis[i][j] << " ";
	//	}
	//	cout << '\n';
	//}

	//cout << endl;
}

void solve()
{
	for (int k = 1; k <= n; ++k)
		for (int i = 1; i <= n; ++i)
			for (int j = 1; j <= n; ++j)
			{
				if (dis[i][j] > dis[i][k] + dis[k][j])
				{
					dis[i][j] = dis[i][k] + dis[k][j];
				}
			}


	for (int i = 1; i <= n; ++i)
	{
		for (int j = 1; j <= n; ++j)
		{
			if (dis[i][j] == INF)
				cout << 0 << " ";
			else
				cout << dis[i][j] << " ";
		}
		cout << '\n';
	}

	int a;
}

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	//freopen("input.txt", "rt", stdin);

	setting();
	solve();

	return 0;
}
```
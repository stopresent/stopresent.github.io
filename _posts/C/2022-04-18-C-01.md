---
title: "따라 배우는 C언어 : 1"

categories:
  - C
tags:
  - C

author_profile: false

sidebar:
  nav: "docs"

date: 2022-04-18
last_modified_at: 2022-04-19
---


## 🙇‍♀️1


### 🪐컴퓨터의 구성 요소

* 컴퓨터의 구성요소
    - 입력장치, 컴퓨터 본체, 출력장치

전원 공급장치, 중앙 처리장치, 입출력 장치, 주 기억장치, 보조 기억장치, 디스플레이, 그래픽스 카드, 메인보드

1. 중앙 처리장치(Central Processing Unit CPU)

<br>

2. 주 기억장치 - 메모리 (Primary Storage - Computer Memory)
    1) Random-Access Memory (RAM)
    2) 전원을 끄면 데이터가 사라짐 (Volatile type of memory)

<br>

3. 그래픽스 카드 (Graphics Card)
    1) GPU (Graphics Processing Unit)

<br>

4. 보조 기억장치 (Secondary Storage)

    1) HDD (Hard Disk Drive) - FDD보다 딱딱해서 Hard임
    2) SSD (Solid-State Drive)
    3) FDD (Floppy Disk Drive)

참고!
왜 C드라이브부터 있나?
A B는 FDD였음!

<br>

### 🪐부팅 절차

* 부팅 절차
    1. 전원 공급
    2. 부트 프로그램 실행
    3. 하드웨어 검사
    4. 운영 체제 로드
    5. 운영 체제 실행

<br>

[메인보드]

[보조기억장치[운영체제(Operating System (OS))]] [ROM BIOS(Basic Input Output System)] [CPU] [주기억장치 - 메모리]

<br>

ROM (Read Only Memory)

<br>

CPU는 보조기억장치를 직접 접근 할 수 없고 주기억장치만 접근가능.

운영체제가 주기억장치로 복사되어 CPU와 같이 일 함.

<br>

### 🪐운영체제가 해주는 일들

운영체제가 해주는 일들

여러개의 프로그램이 작동하면 하드웨어의 자원을 관리하는 것도 운영체제가 해줌.

<br>

[사용자]

                [시스템 프로그램, 응용 프로그램]

                          [운영 체제]

                             [커널]
                                
        [하드웨어(CPU, 메모리, 보조기억장치, 입출력장치..)]


<br>

### 🪐컴퓨터는 왜 2진법을 사용할까?

컴퓨터는 왜 2진수를 사용할까?

컴퓨터는 정보들을 숫자로 바꿔서 처리함.

* 에디슨 효과 (리처드슨 효과, 열전자방출)
    - 금속판을 달구면 전자가 방출 함.
* 진공관의 원리
    - 전기가 흘렀다가 안흘렀다가 조절 가능

* 애니악
    - 진공관 -> 트랜지스터
    - 반도체를 이용해 만들고 대표적 반도체는 실리콘!

껐다 켰다 를 표현하기 위해 0과 1로 표현하는 2진법을 사용함.
전자가 흘렀다가 안흘렀다라는 표현은 에디슨의 전구에서 부터 나오고 
에디슨 효과로 인해 금속판을 달구면 전자가 방출되는데 이때 진공관의 원리로 흐르는 전자를 멈출 수 있다. 여기서 전기가 흘렀다가 안흘렀다를 조절 가능 함. 이후 최초의 컴퓨터인 애니악이 만들어졌고 여기에 진공관은 트랜지스터로 전환되었다.

<br>

### 🪐현대적 컴퓨터의 기본 구조


현대적 컴퓨터의 기본 구조

프로그램을 실행시킬 떄 사람이 직접 플로그를 꽂는다.

애니그마, 앨런 튜링, 폰 노이만, 맨하튼 프로젝트, 

CPU, Memory, Input and Output이 구분 되어있다.

데이터를 주고 받는 통로를 버스라고 함.

시스템 버스는 크게 Control bus, Address bus, Data bus 가 있다.

<br>

### 🪐컴퓨터 메모리의 기본 구조

* 순차 접근 (Sequential access)
    - 순서대로 데이터를 헤집음

* 임의 접근 (Random access)
    - 어디든 바로 접근 할 수있다.

1. control bus : CPU가 메모리에게 데이터를 요청함
2. address bus : 메모리가 CPU에게 주소를 보냄
3. data bus : CPU, 메모리가 데이터를 통신함

CPU와 메모리는 구분되어있는데 메모리에서 똑같은 데이터를 자주 보낼 때 캐쉬메모리에 넣어서 더 빠르게 CPU에 보낸다.

순차 접근은 자기테입에서 쓰였다. 원하는 데이터를 찾을 때 하나하나 다 뒤져봐야 한다.
임의 접근은 주소를 알면 바로 접근 할 수 있다.

메모리의 구조
트랜지스터, 퍼페스터?가 하나의 셀을 이룬다. 하나의 셀에 1비트씩 저장된다. binary digit = bit

주소가 왔다갔다하는 통로와 실제 데이터가 왔다갔다하는 통로는 구분되어있다. 주소는 CPU에서 메모리쪽으로만 감. control bus가 신호를 받을건지 보낼건지 말함. address bus로 CPU가 메모리에게 주소를 보내며 이 주소에 있는 데이터를 보내!라고 명령. data bus를 통해서 메모리가 CPU에게 데이터를 전달.

<br>

### 🪐CPU의 기본 구조

* CPU의 기본 구조

프로그램은 보조기억장치에 저장됨. 실행하고 싶으면 운영체제에게 부탁. 운영체제가 신호를 받으면 보조기억장치의 프로그램은 주기억장치로 이동 및 실행.

* CPU의 언어

1. 기계어 (Machine code)
    - 101010

2. 어셈블리 언어 (Assembly language)
    - LOAD [10]
    - ADD [11]
    - STORE [12]
    - 사람이 이해할 수 있는 언어로 바뀐 것은 니모닉(Mnemonic)이라고 함

3. 고수준 프로그래밍 언어 (High level programming language)
    - A = 3
    - B = 4
    - C = A + B

* CPU 명령어 집합
    * Instruction Set
        - ADD - 숫자 두 개를 더한다
        - COMPARE - 숫자들끼리 비교한다
        - IN - 키보드 같은 입력장치로부터 정보를 입력받는다
        - JUMP - 지정된 메모리 주소로 점프한다
        - JUMP IF - 조건에 따라 점프한다
        - LOAD - 메모리에서 CPU로 정보를 가져온다
        - OUT - 출력 장치로 정보를 출력한다
        - STORE - 메모리에 정보를 저장한다

* CPU의 구성 요소들

    - 제어장치 (Control Unit) -> 여러가지 레지스터들 (Registers)
    - 산술 논리 장치 (ALU Arithmetic Logic Unit) -> 여러가지 레지스터들 (Registers)
    - ALU에서 연산을 하고 레지스터는 작업 공간을 만들어 준다. 

* 레지스터 종류
    - 주소 레지스터 : 읽거나 쓸 메모리 주소 저장
    - 프로그램 카운터 : 다음 명령어의 메모리 주소 저장
    - 데이터 레지스터 : 메모리에서 읽어온 데이터 저장
    - 명령어 레지스터 : 메모리에서 읽어온 명령어 저장
    - 어큐뮬레이터 : 연산에 사용된는 데이터 저장

<br>

### 🪐CPU가 일하는 방법


CPU가 일하는 방법

프로그램이 시작되는 과정
보조기억장치 -> 주기억장치(메모리) <-> CPU

 

제어 버스 (Control Bus) = 제어 장치 (Control Unit) + 산술 논리 장치 (ALU Arithmetic Logic Unit)

레지스터들 = 프로그램 카운터 (Program Counter), 명령어 레지스터 (Current Instruction Register), 메모리 주소 레지스터 (Memory Address Register), 메모리 데이터 레지스터 (Memory Data Register), 어큐뮬레이터 (Accumulator)

```
LOAD [주소10]
ADD [주소11]
STORE [주소12]
```
는 두 숫자를 더하는 과정이다.

A = 3, B = 4, C = A + B 이 과정을 더 자세히 알아보자.

* CPU가 내부에서 하는 일!

1. 프로그램 카운터란 레지스터에 프로그램의 첫번쨰 인스트럭션 명령어가 어느 주소에 있는지 넣는다. OS가 프로그램을 읽고 CPU에게 일해라고 명령하는 것.
CPU가 실행 시켜야할 다음번 명령어의 주소를 가리킴.
2. 프로그램 카운터가 들고있던 주소가 메모리 주소 레지스터로 옮겨감
3. 메모리 주소 레지스터에 있는 주소에 있는 데이터를 가져와서 메모리 데이터 레지스터에 넣는다.
4. 현재 메모리 데이터 레지스터에 있는 데이터는 LOAD 10으로 명령어이다. 명령어란걸 알고 있으니까 명령어 레지스터로 이동한다.
5. 프로그램 카운터가 올라간다. why? 다음번에 읽어 올 (읽어와야 하는) 메모리 주소 (명령어가 들어있는 메모리 주소)를 가지고 있어야 하기 때문에 명령어가 실행되기 전에 카운터가 올라감.
6. 명령어 레지스터에 있는 명령어가 제어장치로 이동 후 해독(Decode)을 한다.
7. LOAD 10을 해독을 하는데 10번 주소의 값을 가져와란 뜻이므로 메모리 주소 레지스터에 10을 넣는다.
8. 10번 주소에 있는 데이터(ex 3)를 메모리 데이터 레지스터에 넣는다.
9. 어큐뮬레이터에 데이터를 넣는다. (연산에 사용되기 때문에)
10. 프로그램 카운터에 이미 다음 명령어의 주소가 있기 때문에 명령어가 들어있는 주소를 가져와야하니까 메모리 주소 레지스터로 가서 주소를 넣는다.
11. 메모리 주소 레지스터에 있는 명령어 데이터를 메모리 데이터 레지스터에 넣는다.
12. 명령어니까 명령어 레지스터로 이동하고 프로그램 카운터가 올라간다.
13. 명령어 레지스터의 명령어는 제어장치로 넘어가고 ADD 11이란 명령어를 해독한다.
14. ADD를 하기 위해서 어큐뮬레이터의 데이터(ex 3)을 산술 논리 장치인 ALU에 올린다.
15. 11번인 주소의 데이터를 읽기 위하여 메모리 주소 레지스터에 주소를 넣는다.
16. 메모리 데이터 레지스터에 그 주소의 값(ex 4)을 넣고 어큐뮬레이터로 이동시킨다.
17. 산술 논리 장치로 들어가서 산술을 한다(ex 3 + 4 = 7)
18. 어큐뮬레이터에 계산 결과(ex 7)를 넣는다.
19. 프로그램 카운터에 있는 다음 명령어 주소가 메모리 주소 레지스터로 옮겨가고 그 주소를 타고가 주소안에 있는 데이터는 메모리 데이터 레지스터에 들어간다.
20. 메모리 데이터 레지스터는 STORE 12가 들어있고, 명령어 레지스터에 들어가고 프로그램 카운터가 증가한다.
21. 명령어 레지스터에 있는 명령어가 제어장치로 옮겨가고 STORE 12를 실행하기 위해 12번의 주소를 타고 가야하므로 메모리 주소 레지스터에 주소를 넣는다.
22. 어큐뮬레이터에 있는 데이터를 메모리 데이터 레지스터로 이동하고 12번 주소에 데이터를 넣는다.

<br>

### 🪐정보의 단위

* 정보 이론의 아버지 = 샤논!
* 정보의 기본 단위는 비트!

* 데이터 vs 정보
    - 데이터 -> 처리과정 -> 정보
    - 디지털 정보의 단위는 디지털 데이터의 단위이기도 하다.

* 1 바이트 byte = 8 비트
    - 메모리 주소의 기본 단위!
    - 8비트는 이유가 없고 관습적임

* 16비트 = 워드 word
* 32비트 워드 word
    - CPU가 데이터를 다루는 기본 단위 = 레지스터의 크기
    - CPU에 따라서 달리지므로 word는 고정된게 아님

<br>

### 🪐이진수


* 10진수 (Decimal numbers)
* 2진수 (Binary numbers)

* 부호가 있는 8비트 정수
    - 10진수 -5
* 2의 보수 방법
1. 5를 2진수로 0000 0101
2. 보수(complement) 1111 1010
3. 더하기 1 -> 1111 1011

첫 비트가 1이면 음수 0이면 양수

2의 보수 정수 표현법에서 -0과 0은 같다!

* 음수를 10진수로 변환
    - 1001 1110
    - 0110 0001 -> 보수 (complement)
    - 0110 0010 -> 더하기 1
    - 1 * 64 + 1 * 32 + 2 = 98 -> -98

부호가 있는 (signed) 정수와 부호가 없는 (unsigned) 정수의 값이 다르기 때문에 조심!

* 8비트 정수의 범위
    - 부호가 있는 (signed) 정수 : -128(10) ~ 127(10)
    - 부호가 없는 (unsigned) 정수 : 0(10) ~ 255(10)
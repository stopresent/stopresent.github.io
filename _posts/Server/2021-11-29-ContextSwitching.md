---
layout: single
title: "ContextSwitching"
categories: Server
tags: Server
author_profile: false
sidebar:
  nav: "docs"
---


## 🙇‍♀️ContextSwitching

Thread.Sleep(1); // 무조건 휴식 => 무조건 1ms만큼 쉬고싶어요

Thread.Sleep(0); // 조건부 양보 => 나보다 우선순위가 낮으면 양보 불가, 나보다 우선순위가 같거나 높으면 쓰레드가 없으면 다시 본인한테

Thread.Yield(); // 관대한 양보 => 관대하게 양보할테니, 지금 실행 가능한 쓰레드가 있으면 실행하세요 => 실행 가능한 애가 없으면 남은시간 소진


```cs
public void Acquire()
{
    while (true)
    {
        // CAD Compare - And - Swap
        int expected = 0;
        int desired = 1;
        if (Interlocked.CompareExchange(ref _locked, desired, expected) == expected)
            break;

        Thread.Sleep(1); // 무조건 휴식 => 무조건 1ms만큼 쉬고싶어요
        Thread.Sleep(0); // 조건부 양보 => 나보다 우선순위가 낮으면 양보 불가, 나보다 우선순위가 같거나 높으면 쓰레드가 없으면 다시 본인한테
        Thread.Yield(); // 관대한 양보 => 관대하게 양보할테니, 지금 실행 가능한 쓰레드가 있으면 실행하세요 => 실행 가능한 애가 없으면 남은시간 소진
    }
}
```

스핀락이 아닌 잠시 휴식을 주는 랜덤메타

### 🪐영혼 이동 비용

로봇직원에게 영혼을 불어줘야 로봇은 작동한다

우리 컴퓨터는 다수의 로봇직원이 운영하지만 코어(영혼)가 하나여서 영혼을 돌려막기를 한다

각 로봇마다 0.1초씩 영혼을 주어 전 로봇이 움직이게 만든다

이때 영혼을 이동시키는 데 드는 비용이 ContextSwitching이다

영혼을 옮기려면 로봇(쓰레드) -> 식당운영자(커널 모드의 cpu코어) -> 다른 로봇(다른 쓰레드) 순으로 영혼이 이동한다

* ContextSwitching
  * 어떤 상태였는지? (내가 연산하고 있는걸 기록하는 레지스터)
  * 무엇을 하고 있었는지? (코드의 실행 상태를 추적하는 레지스터)
  * 식당 구조는 어떤지? (메모리 주소를 접근하는 레지스터)
  * 같은 식당에서 일하던 로봇이 아니면 램에서 가상메모리도 가져옴

빙의를 하고나면 이전의 정보들은 램에 고이 모셔놓는다

### 🪐정리

* 로봇의 영혼이동
  * 로봇영혼이 식당운영자로 이동
  * 로봇의 정보들을 램에 모셔놓기
  * 다른 로봇에게 영혼과 담긴 정보주기

* cpu코어의 이동
  * 쓰레드의 코어가 커널모드 cpu코어로 이동
  * 쓰레드의 정보를 램에 보관
  * 다른 쓰레드의 정보를 램에서 가져오고 쓰레드에게 코어 연결

**영혼을 바꾸는 것이 어마어마한 비용이 들기때문에 경우에 따라선 스핀락 즉, 유저모드에서 계속 시도하는 것이 더 효율적일수 있다**


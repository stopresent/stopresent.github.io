---
title: "C++ Rookiss Part1 C++ 프로그래밍 입문 : 초기화 리스트"

categories:
  - CPP
tags:
  - CPP

author_profile: false

sidebar:
  nav: "docs"

date: 2022-03-30
last_modified_at: 2022-03-30
---


## 🙇‍♀️초기화 리스트

* 초기화 리스트
    - 일단 상속 관계에서 원하는 부모 생성자 호출할 때 필요하다
    - 생성자 내에서 초기화 vs 초기화 리스트
        - 일반 변수는 별 차이 없음
        - 멤버 타입이 클래스인 경우 차이가 난다
        - 정의함과 동시에 초기화가 필요한 경우 (참조 타입, const 타입)

* Is-A (Knight Is-A Player? 기사는 플레이어이다) OK -> 상속관계
* Has-A (Knight Has-A Inventory? 기사는 인벤토리를 포함하고 있다 가지고 있다) OK -> 포함관계



### 🪐초기화 리스트

초기화는 에러방지의 역할을 하고 포인터와 연루되어있을 때 버그 방지의 역할도 한다.
초기화의 방법에는 생성자내 초기화, 초기화 리스트, C++11문법이 있다.

1. 생성자 내 초기화
말 그대로 생성자를 만들 때 초기화를 해주는 것이다. `_hp = hp;`처럼 해주면 된다

2. C++11문법
이 방법은 C#에 있던 방법과 유사한데 방법은 변수를 선언해줌과 동시에 초기화를 해주면 된다. `int _hp = 100;`처럼 해주면 된다.

3. 초기화 리스트
초기화를 해주는 리스트가 있다는 것인데 예시를 바로 보는게 좋을 것 같다.

```cpp
class Knight : public Player
{
public:
	Knight(): Player(1), _hp(100), _inventory(20), _hpRef(_hp),_hpConst(10)
	{
		_hp = 100;
	}

public:
	int _hp;
	Inventory _inventory;

	int& _hpRef;
	const int _hpConst;
};
```
여기서 하나하나 풀어 보자면 `Player(1)`은 부모 클래스의 타입 변환 생성자, `_hp(100)`은 일반 변수 초기화, `_inventory(20)`은 멤버 타입이 클래스 인 경우 초기화, `_hpRef(_hp)` 참조 타입의 경우 초기화이며 생성자 내에서 `_hpRef = _hp`로 적으면 에러가 남, `_hpConst(10)`은 `const`타입의 초기화이며 이도 마찬가지로 생성자 내에서 초기화하면 에러가 난다.


* 에러의 이유
    - 생성자를 만들 때 선처리영역이 끝나면 그 밑 공간은 또 다른 공간이기 때문이다.
    - 이게 무슨 말이냐면 선처리 영역에서 설정해주지 않다면 참조는 가리키는 방향이 없고 `const`는 값을 들고 있지 않다는 뜻이다.

* 멤버 타입이 클래스인 경우
    - `_inventory = Inventory(20)`처럼 해준다면 선처리 영역에서 먼저 `Inventory` 기본 생성자가 만들어 진 뒤 덮어 씌우는 것.
        - 기본 생성자, 타입 변환 생성자 두 개가 만들어진다. (기본 -> 타입 변환 -> 기본 소멸 -> 타입 변환 소멸)
    - `_inventory(20)`처럼 초기화 리스트에 올리면 선처리 영역에서 타입 변환으로 만들어진다.
        - 타입 변환 생성자 하나만 생성.

---
title: "C++ Rookiss Part1 C++ 프로그래밍 입문 : 포인터 마무리 복습"

categories:
  - CPP
tags:
  - CPP

author_profile: false

sidebar:
  nav: "docs"

date: 2022-05-20
last_modified_at: 2022-05-20
---

<br>

## 🙇‍♀️포인터 마무리


<br>

### 🪐포인터 vs 배열 2탄

`int* p;`

포인터는 주소를 담는 바구니! 포인터 변수는 포탈!

<br>

`int arr[10] = { 1,2,3,4,5,6,7,8 };`

배열은 진퉁을 사용, arr에는 첫주소가 담겨져있음, 진퉁을 사용하기에 무거운 느낌을 받아야 함

<br>

[TYPE형 1차원 배열]과 [TYPE*형 포인터]는 완전히 호환이 된다
```cpp
int* p;
int arr[10] = { 1,2,3,4,5,6,7,8 };

cout << p[0] << endl; // 0번째 인자 출력
cout << arr[0] << endl; // 0번쨰 인자 출력
cout << p[5] << endl; // 5번째 인자 출력
cout << arr[5] << endl; // 5번째 인자 출력

cout << *p << endl; // 0번째 인자 출력 p[0]
cout << *arr << endl; // 0번째 인자 출력 arr[0]
cout << *(p + 3) << endl; // 3번째 인자 출력
cout << *(arr + 3) << endl; // 3번째 인자 출력
```

<br>

### 🪐2차원 배열 vs 다중 포인터


`int arr2[2][2] = { {1,2}, {3,4} }; // [1][2][3][4]`

<br>

 주소2[ ] << 4바이트

 주소1 [ 주소2 ]

 pp[ 주소1 ]

`int** pp = (int**)arr2;`

<br>

`cout << (**pp) << endl;`

 **2차원 배열과 2차원 포인터는 호환이 되지 않는다.**

2차원 배열도 곧 1차원 배열이므로 한번만 타고 가면 데이터가 나옴

<br>

```cpp
int arr2[2][2] = { {1,2}, {3,4} };

// [1][2]
// [ 주소 ]
int(*p2)[2] = arr2; // 2차원 배열의 포인터의 타입형 : TYPE(*)[n]
int* p3 = (int*)arr2;

cout << (*p2)[0] << endl; // 1출력 p2[0][0]와 같음
cout << (*p2)[1] << endl; // 2출력
cout << (*(p2 + 1))[0] << endl; // 3출력
cout << (*(p2 + 1))[1] << endl; // 4출력

cout << p2[0][0] << endl; // 1출력
cout << p2[0][1] << endl; // 2출력
cout << p2[1][0] << endl; // 3출력
cout << p2[1][1] << endl; // 4출력


cout << **p2 << *(*p2 + 1) << *(*p2 + 2) << *(*p2 + 3) << endl; // 1234 출력
cout << **(p2 + 0) << *(*(p2 + 0) + 1) << **(p2 + 1) << *(*(p2 + 1) + 1) << endl; // 1234 출력


cout << *p3 << *(p3 + 1) << *(p3 + 2) << *(p3 + 3) << endl; // 1234 출력
```

2차원 배열은 2중 포인터와 호환되지 않는다고 했는데 p2변수는 2차 포인터처럼 사용된다. p2 + 1을 하면 `int[n][m]`에서 n + 1을 한것같다.
*p2 + 1은 m + 1처럼 작동한다

2차원 배열도 결국 1차원 배열이므로 int*로 캐스팅하면 일반 포인터처럼 사용가능함

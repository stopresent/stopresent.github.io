---
title: "ì œ 3íšŒ ì›…ì§„ ì”½í¬ë¹… ê²Œì„ ê°œë°œ ì±Œë¦°ì§€ ê°œë°œ ì¼ì§€ : ì˜¤í•©ì§€ì¡¸ ê°œë°œ ì¼ì§€ 1"

categories:
  - ì œ 3íšŒ ì›…ì§„ ì”½í¬ë¹… ê²Œì„ ê°œë°œ ì±Œë¦°ì§€
tags:
  - ì œ 3íšŒ ì›…ì§„ ì”½í¬ë¹… ê²Œì„ ê°œë°œ ì±Œë¦°ì§€

author_profile: false

sidebar:
  nav: "docs"

date: 2023-06-03
last_modified_at: 2023-06-03
---

## ğŸ™‡â€â™€ï¸ì˜¤í•©ì§€ì¡¸ ê°œë°œ ì¼ì§€

<br>


### ğŸª ê°œë°œ ì¼ì§€!


### ëª©ì°¨

- [ë“¤ì–´ê°€ë©°(ìš”ì•½, í•˜ê³  ì‹¶ì€ ë§ ë“±)](https://www.notion.so/23-06-03-2d54eadcb2df4a8c94a058dff28d9940?pvs=21)
- [ê³„íš](https://www.notion.so/23-06-03-2d54eadcb2df4a8c94a058dff28d9940?pvs=21)
    - ì™„ë£Œí•œ ê³„íš (Done)
    - ì•ìœ¼ë¡œì˜ ê³„íš (To Do List)
- [íŒ€ì› í”¼ë“œë°±](https://www.notion.so/23-06-03-2d54eadcb2df4a8c94a058dff28d9940?pvs=21)
    - ê°•ì¡°í–ˆìœ¼ë©´ ì¢‹ê² ëŠ” ì 
    - ë³´ì™„í•  ì 
- [ìê¸° í”¼ë“œë°±](https://www.notion.so/23-06-03-2d54eadcb2df4a8c94a058dff28d9940?pvs=21)
    - ì‹¤ìˆ˜ í•œ ì 
    - ê³ ì¹  ì 
    - ì•Œê²Œ ëœ ì 
    - ê¿€ íŒ
- [ì‘ì—…í•œ ë‚´ìš©](https://www.notion.so/23-06-03-2d54eadcb2df4a8c94a058dff28d9940?pvs=21)
    - ì½”ë“œ
    - ìº¡ì²˜(ì‚¬ì§„ or ì§¤ or ë™ì˜ìƒ)
- [ê³µë¶€í•œ ë‚´ìš©](https://www.notion.so/23-06-03-2d54eadcb2df4a8c94a058dff28d9940?pvs=21)
- **[ìë£Œ ì¶œì²˜](https://www.notion.so/23-06-03-2d54eadcb2df4a8c94a058dff28d9940?pvs=21)**
- [ë§ˆë¬´ë¦¬í•˜ë©°](https://www.notion.so/23-06-03-2d54eadcb2df4a8c94a058dff28d9940?pvs=21)

---

### ë“¤ì–´ê°€ë©°

ì‹ ê¸°í•˜ê²Œë„ ì˜ˆì„  í†µê³¼ë¥¼ í•˜ì˜€ë‹¤. 

ë³¸ì„  ì§„ì¶œì„ í–ˆìœ¼ë‹ˆ ìƒˆ ë§ˆìŒ ìƒˆ ëœ»ìœ¼ë¡œ ì½”ë“œ ì •ë¦¬ë¥¼ í•˜ë ¤ê³  í•œë‹¤.

ë£¨í‚¤ìŠ¤ì˜ ìœ ë‹ˆí‹° ì½”ë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ì „ì²´ì ì¸ ì½”ë“œ ì •ë¦¬ë¥¼ í•  ê²ƒì´ë‹¤.

---

### ê³„íš [ğŸ”](https://www.notion.so/23-06-03-2d54eadcb2df4a8c94a058dff28d9940?pvs=21)

- **ì™„ë£Œí•œ ê³„íš (Done)**
    - ìŠ¤í† ë¦¬ ëª¨ë“œ ê²Œì„ ì œì‘
- **ì•ìœ¼ë¡œì˜ ê³„íš (To Do List)**
    - Scene ë¶„ê¸°
    - ìŠ¤í† ë¦¬ ëª¨ë“œ ê²Œì„ì„ UIë¡œ ê´€ë¦¬í•˜ê¸°

---

### íŒ€ì› í”¼ë“œë°± [ğŸ”](https://www.notion.so/23-06-03-2d54eadcb2df4a8c94a058dff28d9940?pvs=21)

<aside>
â­ **ê°•ì¡°í–ˆìœ¼ë©´ ì¢‹ê² ëŠ” ì **

- 
</aside>

<aside>
ğŸ›  **ë³´ì™„í•  ì **

- 
</aside>

---

### ìê¸° í”¼ë“œë°± [ğŸ”](https://www.notion.so/23-06-03-2d54eadcb2df4a8c94a058dff28d9940?pvs=21)

ë°¤ì´ë¼ ê·¸ëŸ°ê°€ ìƒê°ì—†ì´ ì½”ë“œë¥¼ ë³´ê³  ìˆìŒ.

ê°„ë‹¨í•œê±´ë° ê·¸ê±¸ ëª»ë³´ê³  ì§€ë‚˜ì¹˜ëŠ” ê²½ìš°ê°€ ì¦ìŒ.

ì¢€ ë©ì²­í•¨.

---

### ê³µë¶€í•œ ë‚´ìš© [ğŸ”](https://www.notion.so/23-06-03-2d54eadcb2df4a8c94a058dff28d9940?pvs=21)

ë°”ì¸ë”© í•¨ìˆ˜ë¥¼ ë³µìŠµ.

- UI_Base ì „ì²´ ì½”ë“œ
    
    ```csharp
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using TMPro;
    using UnityEngine;
    using UnityEngine.EventSystems;
    using UnityEngine.UI;
    
    public abstract class UI_Base : MonoBehaviour
    {
        protected Dictionary<Type, UnityEngine.Object[]> _objects = new Dictionary<Type, UnityEngine.Object[]>();
    
        protected bool _init = false;
    
        public virtual bool Init()
        {
            if (_init)
                return false;
    
            return _init = true;
        }
    
        private void Start()
        {
            Init();
        }
    
        protected void Bind<T>(Type type) where T : UnityEngine.Object
        {
            string[] names = Enum.GetNames(type);
            UnityEngine.Object[] objects = new UnityEngine.Object[names.Length];
            _objects.Add(typeof(T), objects);
    
            for (int i = 0; i < names.Length; i++)
            {
                if (typeof(T) == typeof(GameObject))
                    objects[i] = Utils.FindChild(gameObject, names[i], true);
                else
                    objects[i] = Utils.FindChild<T>(gameObject, names[i], true);
    
                if (objects[i] == null)
                    Debug.Log($"Failed to bind({names[i]})");
            }
        }
    
        protected void BindObject(Type type) { Bind<GameObject>(type); }
        protected void BindImage(Type type) { Bind<Image>(type); }
        protected void BindText(Type type) { Bind<TextMeshProUGUI>(type); }
        protected void BindButton(Type type) { Bind<Button>(type); }
    
        protected T Get<T>(int idx) where T : UnityEngine.Object
        {
            UnityEngine.Object[] objects = null;
            if (_objects.TryGetValue(typeof(T), out objects) == false)
                return null;
    
            return objects[idx] as T;
        }
    
        protected GameObject GetObject(int idx) { return Get<GameObject>(idx); }
        protected TextMeshProUGUI GetText(int idx) { return Get<TextMeshProUGUI>(idx); }
        protected Button GetButton(int idx) { return Get<Button>(idx); }
        protected Image GetImage(int idx) { return Get<Image>(idx); }
    
        public static void BindEvent(GameObject go, Action action, Define.UIEvent type = Define.UIEvent.Click)
        {
            UI_EventHandler evt = Utils.GetOrAddComponent<UI_EventHandler>(go);
    
            switch (type)
            {
                case Define.UIEvent.Click:
                    evt.OnClickHandler -= action;
                    evt.OnClickHandler += action;
                    break;
                case Define.UIEvent.Pressed:
                    evt.OnPressedHandler -= action;
                    evt.OnPressedHandler += action;
                    break;
                case Define.UIEvent.PointerDown:
                    evt.OnPointerDownHandler -= action;
                    evt.OnPointerDownHandler += action;
                    break;
                case Define.UIEvent.PointerUp:
                    evt.OnPointerUpHandler -= action;
                    evt.OnPointerUpHandler += action;
                    break;
            }
        }
    }
    ```
    

í•˜ë‚˜ì”© ë¶„ì„í•˜ê¸°.

`protected Dictionary<Type, UnityEngine.Object[]> _objects = new Dictionary<Type, UnityEngine.Object[]>();`

â‡’ DictionaryëŠ” Keyê°’ì„ í†µí•´ Valueë¥¼ ì €ì¥í•œë‹¤. ì—¬ê¸°ì„œëŠ” Typeì„ Keyë¡œ ì„¤ì •í•˜ê³   UnityEngine.Object[] ë°°ì—´ì´ Valueì´ë‹¤. 

```csharp
// ìˆœì„œê°€ ê¼¬ì—¬ì„œ ì‹œì‘ì´ ì•ˆë˜ëŠ” ê²ƒì„ ë°©ì§€í•˜ëŠ” ì½”ë“œ.
protected bool _init = false;

public virtual bool Init()
{
    if (_init)
        return false;

    return _init = true;
}
```

```csharp
// Bind í•¨ìˆ˜. í…œí”Œë¦¿ì˜ ì¡°ê±´ì€ Objectíƒ€ì…ì´ì—¬ì•¼í•œë‹¤. (Dictionaryì˜ Valueê°€ Objectì´ë‹¤.)
protected void Bind<T>(Type type) where T : UnityEngine.Object
{
		// C#ì˜ ë¦¬í”Œë ‰ì…˜ì„ ì´ìš©í•œ Enumì˜ ê¸€ì ê°€ì ¸ì˜¤ê¸°.
    string[] names = Enum.GetNames(type); 
		
		// Enumì˜ ë‚´ìš©ë¬¼ ê°œìˆ˜ë§Œí¼ Objectë°°ì—´ì„ ë§Œë“ ë‹¤.
    UnityEngine.Object[] objects = new UnityEngine.Object[names.Length];
		
		// í…œí”Œë¦¿ì˜ íƒ€ì…ìœ¼ë¡œ ì˜¤ë¸Œì íŠ¸ ë°°ì—´ì„ Dictionaryì— ë„£ëŠ”ë‹¤.
    _objects.Add(typeof(T), objects);

		// Objectë°°ì—´ì— í•˜ë‚˜í•˜ë‚˜ ë„£ëŠ” ì½”ë“œ, 
		// GameObjectë§Œ ë”°ë¡œ ë§Œë“  ì´ìœ ëŠ” GameObjectê°€ ì»´í¬ë„ŒíŠ¸ê°€ ì•„ë‹ˆê¸° ë•Œë¬¸ì´ë‹¤.
    for (int i = 0; i < names.Length; i++)
    {
        if (typeof(T) == typeof(GameObject))
            objects[i] = Utils.FindChild(gameObject, names[i], true);
        else
            objects[i] = Utils.FindChild<T>(gameObject, names[i], true);

        if (objects[i] == null)
            Debug.Log($"Failed to bind({names[i]})");
    }
}

```

```csharp
// ìì£¼ì“°ëŠ” íƒ€ì…ì„ ì‰½ê²Œ ì“°ê¸°ìœ„í•œ í—¬í¼ í•¨ìˆ˜ë“¤.
protected void BindObject(Type type) { Bind<GameObject>(type); }
protected void BindImage(Type type) { Bind<Image>(type); }
protected void BindText(Type type) { Bind<TextMeshProUGUI>(type); }
protected void BindButton(Type type) { Bind<Button>(type); }
```

```csharp
// Bindëœ Objectë¥¼ ì§ì ‘ ê°€ì ¸ì˜¤ëŠ” í•¨ìˆ˜
protected T Get<T>(int idx) where T : UnityEngine.Object
{
		// ë¹ˆ Objectë°°ì—´ ìƒì„±.
    UnityEngine.Object[] objects = null;

		// ë§Œì•½ ì—†ìœ¼ë©´ null ë°˜í™˜
    if (_objects.TryGetValue(typeof(T), out objects) == false)
        return null;

		// enumì˜ indexì— ë§ëŠ”ê²Œ ì¡´ì¬í•˜ë©´ objectë°˜í™˜.
    return objects[idx] as T;
}
```

```csharp
// Getì„ ì‰½ê²Œ ì“¸ìˆ˜ìˆëŠ” í—¬í¼í•¨ìˆ˜.
protected GameObject GetObject(int idx) { return Get<GameObject>(idx); }
protected TextMeshProUGUI GetText(int idx) { return Get<TextMeshProUGUI>(idx); }
protected Button GetButton(int idx) { return Get<Button>(idx); }
protected Image GetImage(int idx) { return Get<Image>(idx); }

```

```csharp
// GameObjectì— eventë¥¼ bindingí•˜ëŠ” í•¨ìˆ˜.
public static void BindEvent(GameObject go, Action action, Define.UIEvent type = Define.UIEvent.Click)
// ë§¤ê°œë³€ìˆ˜ë¡œ bindingí•  gameobject, ì–´ë–¤ í–‰ë™ì„ í• ê²ƒì¸ì§€ ì •í•˜ëŠ” Action, UIEventë¡œëŠ” ê¸°ë³¸ì ìœ¼ë¡œ Clickì´ë‹¤.
{
    UI_EventHandler evt = Utils.GetOrAddComponent<UI_EventHandler>(go);
		// eventë¥¼ ì—°ë™í•´ì¤„ eventHandler.

    switch (type) // ê° eventì— ë”°ë¼ì„œ action êµ¬ë…í•´ì£¼ê¸°.
    {
        case Define.UIEvent.Click:
            evt.OnClickHandler -= action;
            evt.OnClickHandler += action;
            break;
        case Define.UIEvent.Pressed:
            evt.OnPressedHandler -= action;
            evt.OnPressedHandler += action;
            break;
        case Define.UIEvent.PointerDown:
            evt.OnPointerDownHandler -= action;
            evt.OnPointerDownHandler += action;
            break;
        case Define.UIEvent.PointerUp:
            evt.OnPointerUpHandler -= action;
            evt.OnPointerUpHandler += action;
            break;
    }
}

```

---

### ë§ˆë¬´ë¦¬í•˜ë©° [ğŸ”](https://www.notion.so/23-06-03-2d54eadcb2df4a8c94a058dff28d9940?pvs=21)

ê³µë¶€ ì¢€ ì—´ì‹¬íˆí•´ì„œ ì˜ ì‚¬ìš©í•´ë³´ì.
---
title: "제 3회 웅진 씽크빅 게임 개발 챌린지 개발 일지 : 오합지졸 개발 일지 1"

categories:
  - 제 3회 웅진 씽크빅 게임 개발 챌린지
tags:
  - 제 3회 웅진 씽크빅 게임 개발 챌린지

author_profile: false

sidebar:
  nav: "docs"

date: 2023-06-03
last_modified_at: 2023-06-03
---

## 🙇‍♀️오합지졸 개발 일지

<br>


### 🪐 개발 일지!


### 목차

- [들어가며(요약, 하고 싶은 말 등)](https://www.notion.so/23-06-03-2d54eadcb2df4a8c94a058dff28d9940?pvs=21)
- [계획](https://www.notion.so/23-06-03-2d54eadcb2df4a8c94a058dff28d9940?pvs=21)
    - 완료한 계획 (Done)
    - 앞으로의 계획 (To Do List)
- [팀원 피드백](https://www.notion.so/23-06-03-2d54eadcb2df4a8c94a058dff28d9940?pvs=21)
    - 강조했으면 좋겠는 점
    - 보완할 점
- [자기 피드백](https://www.notion.so/23-06-03-2d54eadcb2df4a8c94a058dff28d9940?pvs=21)
    - 실수 한 점
    - 고칠 점
    - 알게 된 점
    - 꿀 팁
- [작업한 내용](https://www.notion.so/23-06-03-2d54eadcb2df4a8c94a058dff28d9940?pvs=21)
    - 코드
    - 캡처(사진 or 짤 or 동영상)
- [공부한 내용](https://www.notion.so/23-06-03-2d54eadcb2df4a8c94a058dff28d9940?pvs=21)
- **[자료 출처](https://www.notion.so/23-06-03-2d54eadcb2df4a8c94a058dff28d9940?pvs=21)**
- [마무리하며](https://www.notion.so/23-06-03-2d54eadcb2df4a8c94a058dff28d9940?pvs=21)

---

### 들어가며

신기하게도 예선 통과를 하였다. 

본선 진출을 했으니 새 마음 새 뜻으로 코드 정리를 하려고 한다.

루키스의 유니티 코드를 사용하여 전체적인 코드 정리를 할 것이다.

---

### 계획 [🔝](https://www.notion.so/23-06-03-2d54eadcb2df4a8c94a058dff28d9940?pvs=21)

- **완료한 계획 (Done)**
    - 스토리 모드 게임 제작
- **앞으로의 계획 (To Do List)**
    - Scene 분기
    - 스토리 모드 게임을 UI로 관리하기

---

### 팀원 피드백 [🔝](https://www.notion.so/23-06-03-2d54eadcb2df4a8c94a058dff28d9940?pvs=21)

<aside>
⭐ **강조했으면 좋겠는 점**

- 
</aside>

<aside>
🛠 **보완할 점**

- 
</aside>

---

### 자기 피드백 [🔝](https://www.notion.so/23-06-03-2d54eadcb2df4a8c94a058dff28d9940?pvs=21)

밤이라 그런가 생각없이 코드를 보고 있음.

간단한건데 그걸 못보고 지나치는 경우가 잦음.

좀 멍청함.

---

### 공부한 내용 [🔝](https://www.notion.so/23-06-03-2d54eadcb2df4a8c94a058dff28d9940?pvs=21)

바인딩 함수를 복습.

- UI_Base 전체 코드
    
    ```csharp
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using TMPro;
    using UnityEngine;
    using UnityEngine.EventSystems;
    using UnityEngine.UI;
    
    public abstract class UI_Base : MonoBehaviour
    {
        protected Dictionary<Type, UnityEngine.Object[]> _objects = new Dictionary<Type, UnityEngine.Object[]>();
    
        protected bool _init = false;
    
        public virtual bool Init()
        {
            if (_init)
                return false;
    
            return _init = true;
        }
    
        private void Start()
        {
            Init();
        }
    
        protected void Bind<T>(Type type) where T : UnityEngine.Object
        {
            string[] names = Enum.GetNames(type);
            UnityEngine.Object[] objects = new UnityEngine.Object[names.Length];
            _objects.Add(typeof(T), objects);
    
            for (int i = 0; i < names.Length; i++)
            {
                if (typeof(T) == typeof(GameObject))
                    objects[i] = Utils.FindChild(gameObject, names[i], true);
                else
                    objects[i] = Utils.FindChild<T>(gameObject, names[i], true);
    
                if (objects[i] == null)
                    Debug.Log($"Failed to bind({names[i]})");
            }
        }
    
        protected void BindObject(Type type) { Bind<GameObject>(type); }
        protected void BindImage(Type type) { Bind<Image>(type); }
        protected void BindText(Type type) { Bind<TextMeshProUGUI>(type); }
        protected void BindButton(Type type) { Bind<Button>(type); }
    
        protected T Get<T>(int idx) where T : UnityEngine.Object
        {
            UnityEngine.Object[] objects = null;
            if (_objects.TryGetValue(typeof(T), out objects) == false)
                return null;
    
            return objects[idx] as T;
        }
    
        protected GameObject GetObject(int idx) { return Get<GameObject>(idx); }
        protected TextMeshProUGUI GetText(int idx) { return Get<TextMeshProUGUI>(idx); }
        protected Button GetButton(int idx) { return Get<Button>(idx); }
        protected Image GetImage(int idx) { return Get<Image>(idx); }
    
        public static void BindEvent(GameObject go, Action action, Define.UIEvent type = Define.UIEvent.Click)
        {
            UI_EventHandler evt = Utils.GetOrAddComponent<UI_EventHandler>(go);
    
            switch (type)
            {
                case Define.UIEvent.Click:
                    evt.OnClickHandler -= action;
                    evt.OnClickHandler += action;
                    break;
                case Define.UIEvent.Pressed:
                    evt.OnPressedHandler -= action;
                    evt.OnPressedHandler += action;
                    break;
                case Define.UIEvent.PointerDown:
                    evt.OnPointerDownHandler -= action;
                    evt.OnPointerDownHandler += action;
                    break;
                case Define.UIEvent.PointerUp:
                    evt.OnPointerUpHandler -= action;
                    evt.OnPointerUpHandler += action;
                    break;
            }
        }
    }
    ```
    

하나씩 분석하기.

`protected Dictionary<Type, UnityEngine.Object[]> _objects = new Dictionary<Type, UnityEngine.Object[]>();`

⇒ Dictionary는 Key값을 통해 Value를 저장한다. 여기서는 Type을 Key로 설정하고  UnityEngine.Object[] 배열이 Value이다. 

```csharp
// 순서가 꼬여서 시작이 안되는 것을 방지하는 코드.
protected bool _init = false;

public virtual bool Init()
{
    if (_init)
        return false;

    return _init = true;
}
```

```csharp
// Bind 함수. 템플릿의 조건은 Object타입이여야한다. (Dictionary의 Value가 Object이다.)
protected void Bind<T>(Type type) where T : UnityEngine.Object
{
		// C#의 리플렉션을 이용한 Enum의 글자 가져오기.
    string[] names = Enum.GetNames(type); 
		
		// Enum의 내용물 개수만큼 Object배열을 만든다.
    UnityEngine.Object[] objects = new UnityEngine.Object[names.Length];
		
		// 템플릿의 타입으로 오브젝트 배열을 Dictionary에 넣는다.
    _objects.Add(typeof(T), objects);

		// Object배열에 하나하나 넣는 코드, 
		// GameObject만 따로 만든 이유는 GameObject가 컴포넌트가 아니기 때문이다.
    for (int i = 0; i < names.Length; i++)
    {
        if (typeof(T) == typeof(GameObject))
            objects[i] = Utils.FindChild(gameObject, names[i], true);
        else
            objects[i] = Utils.FindChild<T>(gameObject, names[i], true);

        if (objects[i] == null)
            Debug.Log($"Failed to bind({names[i]})");
    }
}

```

```csharp
// 자주쓰는 타입을 쉽게 쓰기위한 헬퍼 함수들.
protected void BindObject(Type type) { Bind<GameObject>(type); }
protected void BindImage(Type type) { Bind<Image>(type); }
protected void BindText(Type type) { Bind<TextMeshProUGUI>(type); }
protected void BindButton(Type type) { Bind<Button>(type); }
```

```csharp
// Bind된 Object를 직접 가져오는 함수
protected T Get<T>(int idx) where T : UnityEngine.Object
{
		// 빈 Object배열 생성.
    UnityEngine.Object[] objects = null;

		// 만약 없으면 null 반환
    if (_objects.TryGetValue(typeof(T), out objects) == false)
        return null;

		// enum의 index에 맞는게 존재하면 object반환.
    return objects[idx] as T;
}
```

```csharp
// Get을 쉽게 쓸수있는 헬퍼함수.
protected GameObject GetObject(int idx) { return Get<GameObject>(idx); }
protected TextMeshProUGUI GetText(int idx) { return Get<TextMeshProUGUI>(idx); }
protected Button GetButton(int idx) { return Get<Button>(idx); }
protected Image GetImage(int idx) { return Get<Image>(idx); }

```

```csharp
// GameObject에 event를 binding하는 함수.
public static void BindEvent(GameObject go, Action action, Define.UIEvent type = Define.UIEvent.Click)
// 매개변수로 binding할 gameobject, 어떤 행동을 할것인지 정하는 Action, UIEvent로는 기본적으로 Click이다.
{
    UI_EventHandler evt = Utils.GetOrAddComponent<UI_EventHandler>(go);
		// event를 연동해줄 eventHandler.

    switch (type) // 각 event에 따라서 action 구독해주기.
    {
        case Define.UIEvent.Click:
            evt.OnClickHandler -= action;
            evt.OnClickHandler += action;
            break;
        case Define.UIEvent.Pressed:
            evt.OnPressedHandler -= action;
            evt.OnPressedHandler += action;
            break;
        case Define.UIEvent.PointerDown:
            evt.OnPointerDownHandler -= action;
            evt.OnPointerDownHandler += action;
            break;
        case Define.UIEvent.PointerUp:
            evt.OnPointerUpHandler -= action;
            evt.OnPointerUpHandler += action;
            break;
    }
}

```

---

### 마무리하며 [🔝](https://www.notion.so/23-06-03-2d54eadcb2df4a8c94a058dff28d9940?pvs=21)

공부 좀 열심히해서 잘 사용해보자.
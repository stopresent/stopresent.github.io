---
title: "제 3회 웅진 씽크빅 게임 개발 챌린지 개발 일지 : 오합지졸 개발 일지 2"

categories:
  - 제 3회 웅진 씽크빅 게임 개발 챌린지
tags:
  - 제 3회 웅진 씽크빅 게임 개발 챌린지

author_profile: false

sidebar:
  nav: "docs"

date: 2023-06-06
last_modified_at: 2023-06-06
---

## 🙇‍♀️오합지졸 개발 일지

<br>


### 🪐 개발 일지!

[23.06.06] 개발일지 (-오합지졸)
목차
들어가며
[플머] 화살 날리기 기능 제작 (서현재, 배정훈, 윤지연)
[아트] 캐릭터 디자인 (서민영)
본선 진출 후 개발 내용
마무리
1. 들어가며
오합지졸 팀은 프로그래머 4명, 아트 1명, 공동 기획으로 구성된 팀이다. 본선 진출과 함께 빠르게 달려보고자 했지만, 프로그래머 3명의 시험기간이 6월 8일 ~ 6월 21일인 관계로 6월 21일까지는 예선을 준비하던 과정들을 하나씩 풀어갈 예정이다. 그렇다고 예선 준비 과정만 풀겠다는 것은 아니다. 본선 진출 후 개발도 프로그래머 1명과 아트 1명이 계속 하고 있기 때문에 이에 대한 내용은 글 하단에 꾸준히 넣을 예정이다.

참고
제목 형태: [담당분야] 작업 내용 (담당자)
플머: 프로그래머의 줄임말
2. [플머] 화살 날리기 기능 제작 (서현재, 배정훈, 윤지연)
2-1. 화살 프리팹 초안 제작 (배정훈)
① SymbolArrow 프리팹 제작
화살 형태의 프리팹으로 동일한 형태의 Collider를 가진다.
자식으로 숫자와 기호를 텍스트로 표시할 TextMeshPro를 보유하고 있다.
Tag: SymbolArrow→ 플레이어와 충돌 시 화살과 충돌했음을 감지하기 위해서다.

🛠 보완할 점
하나의 부모에게 화살의 머리, 몸통, 기호영역 등 여러 오브젝트가 붙어있는 점
→ 여러 화살을 한 화면에 놓았을 때 관리가 번거로울 것으로 판단


ArrowController.cs 코드
화살을 통째로 관리하는 ArrowController.cs 스크립트를 추가하고, 이를 최상위 SymbolArrow오브젝트에 컴포넌트로 추가했다.

Symbol 변수

화살에 적힐 기호, inspector 창에서 간편하게 기호를 바꿀 수 있도록 했다.
화살이 생성될 때 임의의 숫자([0~9] 자연수 중 하나)를 갖는다.

```csharp
<public class ArrowController : MonoBehaviour
{
    public string Symbol;      

    private void Start()
    {
        tmp = GetComponentInChildren<TextMeshPro>();
        tmp.text = Symbol;

        if (Symbol.Length > 1)  
        {
            Symbol = Random.Range(0, 10).ToString();
            tmp.text = Symbol;
        }

    }
}
```

2-2. 화살 프리팹 정리 및 패턴 부여 (서현재, 윤지연)
MessMath의 주요 기능인 랜덤하게 날아오는 화살의 패턴을 세부적으로 설정했다.

① Arrow 프리팹으로 수정
기존의 SymbolArrow 프리팹을 화살이 동적 생성되도록 만들기 위해 Arrow라는 프리팹으로 수정했다.

Arrow 프리팹은 Arrow.cs 를 컴포넌트로 가지는 오브젝트이다.

게임 씬에서 ArrowController 오브젝트의 자식 오브젝트로 동적 생성된다.

② Arrow.cs 스크립트 작성
각 Arrow 오브젝트의 속성을 가지고 있는 스크립트이다.

현재는 종류, 숫자, 연산 기호, 속도, 시작 위치, 방향을 가지고 있지만 여기서 삭제 될 수도, 추가되는 속성이 있을 수도 있다.

```csharp
// Arrow.cs 코드
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Arrow : MonoBehaviour
{
    public int type {get; set;}   // 화살 종류 = 숫자 or 연산 기호
    public int num  {get; set;}   // 숫자 (1 ~ 9)
    public char mathematicalSymbol  {get; set;} // 연산 기호 (+, -, x, /)
    public float speed  {get; set;} // 화살이 날라가는 속도
    public Vector2 startPosition {get; set;} // 화살의 시작 위치
    public Vector2 direction  {get; set;} // 화살이 날라가는 방향
}
```
③ ArrowController.cs 스크립트 작성
Arrow 프리팹을 패턴에 맞게 게임 씬에 동적으로 생성하는 스크립트이다.

화살이 가질 수 있는 속성들을 패턴에 맞게 설정한 후 게임씬에 날려보내는 역할을 한다.

현재는 테스트를 위한 코드라 3초 후 자동 삭제 되도록 만들어 두었다.

```csharp
// ArrowController.cs 코드
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class ArrowController : MonoBehaviour
{
    // 화살의 시작 위치 랜덤 생성 x = -11.1 ~ 11.11,  y = 5 고정
    private const float MIN_X = -11.1f;
    private const float MAX_X = 11.11f;
    private const int MAX_CNT = 10;
    private const int MAX_NUM_ARROW = 3;
    private const int MAX_SYMBOL_ARROW = 2;
    private int arrowCnt = 0;
    private int numArrowCnt = 0;
    private int symbolArrowCnt = 0;
    private Color red = new Color(1,0,0,1);
    private Color blue = new Color(0,0,1,1);
    public GameObject player;
    public GameObject arrowPrefab;
    
    void Start()
    {
        StartCoroutine("SetArrowGenerationTime",3f);
    }

    void Update()
    {
        // TODO: 플레이어 위치 정보 얻어오기(Player Controller 완성되면 진행)
    }

    // 화살이 생성되는 시간 조절하는 함수 
        // 현재 화살 개수가 몇개 나왔는지 체크
    IEnumerator SetArrowGenerationTime(float delayTime)
    {
        WaitForSeconds waitForSeconds = new WaitForSeconds(delayTime);
        if(arrowCnt < MAX_CNT) {
            ShootArrow();
            yield return waitForSeconds;
            StartCoroutine("SetArrowGenerationTime", 3f);
        }
        else yield return waitForSeconds;
    }
    
    // 현재 생성된 화살의 타입 숫자인지 기호인지 설정하는 함수 
    // TODO: 해당 함수에선 현재 생성된 화살의 숫자와 기호 탐색 후 설정 해줘야 함
    int SetArrowType(Arrow arrow)
    {
        arrow.type = Random.Range(0, 2);
        if (arrow.type == 0) {
            numArrowCnt++;
            if(MAX_NUM_ARROW < numArrowCnt) {
                arrow.type = 1;
                numArrowCnt = 0;
                return arrow.type;
            }
        }
        symbolArrowCnt++;
        if(MAX_SYMBOL_ARROW < symbolArrowCnt) {
            arrow.type = 0;
            symbolArrowCnt = 0;
        }
        return arrow.type;
    }

    void SetArrowNum(Arrow arrow)
    {
        arrow.num = Random.Range(1, 10);
    }

    void SetArrowSymbol(Arrow arrow)
    {
        switch(Random.Range(0, 4))
        {
            case 0: {
                arrow.mathematicalSymbol = '+';
                break;
            }
            case 1: {
                arrow.mathematicalSymbol = '-';
                break;
            }
            case 2: {
                arrow.mathematicalSymbol = 'x';
                break;
            }
            case 3: {
                arrow.mathematicalSymbol = '/';
                break;
            }
        }
    }

    // 화살의 방향 조절하는 함수 
        // 현재 플레이어의 위치로 설정
    void SetArrowDirection(Arrow arrow)
    {
        Vector2 playerPos = new Vector2(player.transform.position.x, player.transform.position.y);
        arrow.direction = playerPos - arrow.startPosition;
    }
    
    // 화살의 속도 조절하는 함수 
    void SetArrowSpeed(Arrow arrow)
    {
        arrow.speed = Random.Range(0.5f, 0.9f);
    }

    // 화살의 생성 위치 조절하는 함수 
    void SetArrowStartPosition(Arrow arrow)
    {
        arrow.startPosition = new Vector2(Random.Range(MIN_X, MAX_X), 5f);
    }

    // 화살 설정하는 함수
    void SetArrow(Arrow arrow)
    {
        if(SetArrowType(arrow) == 0) 
            SetArrowNum(arrow);
        else 
            SetArrowSymbol(arrow);
        SetArrowStartPosition(arrow);
        SetArrowDirection(arrow);
        SetArrowSpeed(arrow);
    }

    // 화살 동적 생성하는 함수
    GameObject MakeArrow()
    {
        GameObject arrowObject = Instantiate(arrowPrefab, this.transform); 
        Arrow arrow = arrowObject.GetComponent<Arrow>();
        SetArrow(arrow);
        arrowObject.transform.position = arrow.startPosition;
        arrowCnt++;
        return arrowObject;
    }

    // 현재 플레이어의 위치를 향해 오브젝트 날리기 
    void ShootArrow()
    {
        GameObject arrowObj = MakeArrow();
        Arrow arrow =  arrowObj.GetComponent<Arrow>();
        Rigidbody2D arrowRigid = arrowObj.GetComponent<Rigidbody2D>();
        arrowRigid.AddForce(arrow.direction * arrow.speed, ForceMode2D.Impulse);

        SpriteRenderer spriteRenderer = arrowObj.GetComponent<SpriteRenderer>();
        if(arrow.type == 0) 
            spriteRenderer.color = red;
        else 
            spriteRenderer.color = blue;

        Destroy(arrowObj, 3f);
    }
}
```

⭐ 유지할 점
ArrowController를 통해 Arrow의 랜덤 생성을 관리하는 점


🛠 보완할 점
화살의 시작 위치
화살 이미지 추가 및 숫자, 기호가 표시 될 TMP 오브젝트 추가


❗ 실수 한 점
화살을 날릴 때 화살의 속도를 Normalization을 해줬어야 했다.

3. [아트] 캐릭터 디자인 (서민영)
주인공 일러스트


성별
주인공을 설정 할 때 늘 여러가지를 고려한다. 먼저 우리 게임의 컨셉에 수학자가 가호로 등장한다는 점에서 성비가 남성에 치우침에 따라 성별을 여자 아이로 설정했다.

연령
그리고 아이들은 어른을 동경하지만 친근감을 줄 수 있는 것은 또래 이므로 비슷한 나잇대의 소녀로 설정했다. 앳된 얼굴과 달리 팔,다리가 길쭉길쭉한 것은 아트의 초등학생 때의 경험으로 그게 예뻐 보였기 때문이다. (지금 생각해 보자면 비정상적일 정도로 과장된 큰 눈과 길고 마른 몸이 왜 그렇게 예뻐 보였는지 모르겠다.)

혹시 몰라 SD캐릭터 쪽도 비슷한 계열로 디자인 해서 비교해봤다.

성격
주인공이 완벽한 모범생이면 스토리 개연성과 진행이 어려울 수 있다. 때문에 평범 혹은 부진한 성적이라는 설정은 다소 덜렁거리지만 적극적이고 활발한 성격의 방향으로 잡았다. 발랄한 성격의 주인공이 실수로 친 사고를 주변인과 함께 수습한다는 왕도적 클리셰가 잘 어울리는 쪽으로 디자인 했다.

밝은 성격, 활동성을 강조하기 위해 짧은 로브와 투피스 치마를 택했다. 어린이들의 워너비 마법소녀 애니메이션에 꼭 등장하는 리본이나 프릴 등 좋아할 것 같은 요소도 넣었다. 그리고 수학과 친근해 지는 것이 목적인 게임이니 자연스럽게 친숙해지도록 수학 기호를 의상 디자인으로 조금씩 첨가해 보았다.


⭐ 참고
추후 디자인할 주인공의 다른 코스튬에서도 수학에 관련된 기호를 넣을 생각이다. 주 타겟층인 초등학생이 루트나 펙토리얼 등을 사용할 일은 없겠지만 지금이라도 긍정적인 기분으로 자주 봐서 어렴풋한 친근감을 느꼈으면 하는 바람이다.
현재 주인공 디자인은 초기 디자인이라 수정될 가능성이 있다.

4. 본선 진출 후 개발 내용
4-1. 연습모드 UI 제작 (플머-서현재)
① PracticeGameScene 초기 세팅


PracticeGameScene에서 해당 씬을 관리하는 빈 오브젝트인 @Scene 의 컴포넌트로PracticeGameScene.cs 를 넣어줬다.

```csharp
// PracticeGameScene.cs 코드
<using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PracticeGameScene : BaseScene
{
    protected override bool Init()
    {
        if (base.Init() == false)
            return false;

				// SceneType을 Define.Scene에 추가한 type인 PracticeGameScene으로 설정
        SceneType = Define.Scene.PracticeGameScene;

				// 현재 씬으로 UI_PracticeGame 프리펩을 불러와 UI로 추가
        Managers.UI.ShowSceneUI<UI_PracticeGame>();
        return true;
    }
}
```
② 연습모드 UI 설정을 위한 UI_PracticeGame.cs


매쓰피드 API 키를 받기 전이라 간단하게 틀만 만들었다.
QuestionText는 3 + 3 = 으로 만들고, LeftAnswerText과 RightAnswerText은 각각 6, 9 로 만들어 테스트했다.

```csharp
UI_PracticeGame.cs 코드
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class UI_PracticeGame : UI_Scene
{
    enum Texts
    {
        QuestionText,
        LeftAnswerText,
        RightAnswerText,
    }
    enum Images
    {
        BG,
    }

    private void Start()
    {
        Init();
    }

    public override bool Init()
    {
        if (base.Init() == false)
            return false;

        BindText(typeof(Texts));
        BindButton(typeof(Buttons));
        BindObject(typeof(GameObjects));
        BindImage(typeof(Images));

        // TODO: 매쓰피드 API 보고 수정
        GetText((int)Texts.QuestionText).text = "3 + 3 =";
        GetText((int)Texts.LeftAnswerText).text = "6";
        GetText((int)Texts.RightAnswerText).text = "9";

        return true;
    }
}
```

5. 마무리 (예고)
내일은 아래의 내용이 담긴 개발일지를 올릴 예정이다.

프로그래머
화살을 먹었을 때 수식 제작하는 기능
화살의 방향이 플레이어를 보도록 회전시키는 기능
아트
가호, 가호 아이콘, 공격 모션
---
title: "C++ Rookiss Part2 ê²Œì„ ìˆ˜í•™ê³¼ DirectX12 : Scene ë³µìŠµ"

categories:
  - DirectX12
tags:
  - DirectX12

author_profile: false

sidebar:
  nav: "docs"

date: 2022-10-16
last_modified_at: 2022-10-16
---

<br>

1. game.cppì—ì„œ ê·¸ë¦° ëª¨ë¥¸ ê²ƒ ë“¤ì„ Sceneìœ¼ë¡œ ê´€ë¦¬í•˜ì—¬ ì •ë¦¬.
2. Updateë¬¸ì„ í•˜ë‚˜ë¡œ í†µí•©
3. Input, Timerë¥¼ Singletonìœ¼ë¡œ ë³€ê²½

Manager í•„í„°ë¥¼ ë§Œë“¤ê³  SceneManager, Scene í´ë˜ìŠ¤ ìƒì„±

SceneManagerì€ ì‹±ê¸€í†¤ íŒ¨í„´ìœ¼ë¡œ ë§Œë“¤ ê²ƒì¸ë° ì‹±ê¸€í†¤ íŒ¨í„´ì„ ë§Œë“œëŠ” ê²ƒì„ ë§¤í¬ë¡œ í•œë‹¤.

```cpp
#define DECLARE_SINGLE(type)		            \
private:							            \
	type() {}						            \
	~type() {}						            \
public:								            \
	static type* GetInstance()		            \
	{								            \
		static type instance;		            \
		return &instance;			            \
	}								            \
```

ì›ë˜ defineì€ í•œì¤„ë§Œ ì½ëŠ”ë° `\` ë¥¼ ë¶™ì´ë©´ ì•„ë˜ ì¤„ê¹Œì§€ ì´ì–´ì„œ ì½ëŠ”ë‹¤.

ì‹±ê¸€í†¤ íŒ¨í„´ì„ ë§Œë“œëŠ” ê±¸ ë³´ë©´ staticìœ¼ë¡œ ìœ ì¼ì„±ì„ ì±™ê¸°ê³  ìˆëŠ” ê±¸ ë³¼ ìˆ˜ ìˆë‹¤. (ìŠ¤íƒ ë©”ëª¨ë¦¬ ì•„ë‹˜!)

---

### ğŸš€ Scene

```cpp
#pragma once

class GameObject;

class Scene
{
public:
	void Awake();
	void Start();
	void Update();
	void LateUpdate();

	void AddGameObject(shared_ptr<GameObject> gameObject);
	void RemoveGameObject(shared_ptr<GameObject> gameObject);

private:
	vector<shared_ptr<GameObject>> _gameObjects;
};
```

`vector<shared_ptr<GameObject>> _gameObjects;` ë¡œ gameObjectsë¥¼ ë“¤ê³  ìˆê³  êµ¬ì¡°ëŠ” ê°„ë‹¨í•˜ë‹¤.

```cpp
#include "pch.h"
#include "Scene.h"
#include "GameObject.h"

void Scene::Awake()
{
	for (const shared_ptr<GameObject>& gameObject : _gameObjects)
	{
		gameObject->Awake();
	}
}

void Scene::Start()
{
	for (const shared_ptr<GameObject>& gameObject : _gameObjects)
	{
		gameObject->Start();
	}
}

void Scene::Update()
{
	for (const shared_ptr<GameObject>& gameObject : _gameObjects)
	{
		gameObject->Update();
	}
}

void Scene::LateUpdate()
{
	for (const shared_ptr<GameObject>& gameObject : _gameObjects)
	{
		gameObject->LateUpdate();
	}
}

void Scene::AddGameObject(shared_ptr<GameObject> gameObject)
{
	_gameObjects.push_back(gameObject);
}

void Scene::RemoveGameObject(shared_ptr<GameObject> gameObject)
{
	auto findIt = std::find(_gameObjects.begin(), _gameObjects.end(), gameObject);
	if (findIt != _gameObjects.end())
	{
		_gameObjects.erase(findIt);
	}
}
```

Awake, Start, Update, LateUpdateì—ì„œì˜ forë¬¸ì€ C#ì—ì„œ foreachë‘ ë¹„ìŠ·í•œ ë¬¸ë²•ìœ¼ë¡œ ë‚´ìš©ë¬¼ì„ ìˆ˜ì •í•˜ì§€ ì•Šì„ ë•Œ ì‚¬ìš© ê°€ëŠ¥í•˜ë‹¤. ê°€ì‹œì„±ì´ ì¢‹ë‹¤.

---

### ğŸš€ SceneManager

```cpp
#pragma once

class Scene;

class SceneManager
{
	DECLARE_SINGLE(SceneManager);

public:
	void Update();
	void LoadScene(wstring sceneName);

public:
	shared_ptr<Scene> GetActiveScene() { return _activeScene; }

private:
	shared_ptr<Scene> LoadTestScene();

private:
	shared_ptr<Scene> _activeScene;

};
```

`DECLARE_SINGLE(SceneManager);` ìœ¼ë¡œ ì‹±ê¸€í†¤ì¸ê±¸ í™•ì¸ ê°€ëŠ¥. ë‚˜ë¨¸ì§€ëŠ” ê°€ë³ê²Œ í›ì–´ë³´ë©´ ë˜ëŠ” êµ¬ì¡°.

```cpp
#include "pch.h"
#include "SceneManager.h"
#include "Scene.h"
#include "Engine.h"
#include "Material.h"

#include "GameObject.h"
#include "MeshRenderer.h"

void SceneManager::Update()
{
	if (_activeScene == nullptr) return;

	_activeScene->Update();
	_activeScene->LateUpdate();
}

void SceneManager::LoadScene(wstring sceneName)
{
	// TODO : ê¸°ì¡´ Scene ì •ë¦¬
	// TODO : íŒŒì¼ì—ì„œ Scene ì •ë³´ ë¡œë“œ

	_activeScene = LoadTestScene();

	_activeScene->Awake();
	_activeScene->Start();
}
```

LoadTestSceneì´ ê¸¸ì–´ì„œ ë¶„ë¦¬í•¨. ìœ„ì—ë§Œ ë”°ë¡œ ë³´ë©´ updateì—ì„œëŠ” í˜„ì¬ ì”¬ ì²´í¬ í›„ ìˆìœ¼ë©´

`_activeScene->Update();` `_activeScene->LateUpdate();` í•´ì¤Œ.

LoadSceneì€ ì¼ë‹¨ í…ŒìŠ¤íŠ¸ë¡œ LoadTestSceneì„ í˜„ì¬ ì”¬ì— ë„£ê³  Awake, Startë¥¼ í•´ì¤Œ

```cpp
shared_ptr<Scene> SceneManager::LoadTestScene()
{
	shared_ptr<Scene> scene = make_shared<Scene>();

	// Test Object
	shared_ptr<GameObject> gameObject = make_shared<GameObject>();

	vector<Vertex> vec(4);
	vec[0].pos = Vec3(-0.5f, 0.5f, 0.5f);
	vec[0].color = Vec4(1.f, 0.f, 0.f, 1.f);
	vec[0].uv = Vec2(0.f, 0.f);
	vec[1].pos = Vec3(0.5f, 0.5f, 0.5f);
	vec[1].color = Vec4(0.f, 1.f, 0.f, 1.f);
	vec[1].uv = Vec2(1.f, 0.f);
	vec[2].pos = Vec3(0.5f, -0.5f, 0.5f);
	vec[2].color = Vec4(0.f, 0.f, 1.f, 1.f);
	vec[2].uv = Vec2(1.f, 1.f);
	vec[3].pos = Vec3(-0.5f, -0.5f, 0.5f);
	vec[3].color = Vec4(0.f, 1.f, 0.f, 1.f);
	vec[3].uv = Vec2(0.f, 1.f);

	// ì‚¼ê°í˜•ì˜ ê°ê¸° ìˆœì„œëŠ” ì‹œê³„ ë°©í–¥
	vector<uint32> indexVec;
	{
		indexVec.push_back(0);
		indexVec.push_back(1);
		indexVec.push_back(2);
	}

	{
		indexVec.push_back(3);
		indexVec.push_back(0);
		indexVec.push_back(2);
	}

	gameObject->Init(); // Transform

	shared_ptr<MeshRenderer> meshRenderer = make_shared<MeshRenderer>();

	{
		shared_ptr<Mesh> mesh = make_shared<Mesh>();
		mesh->Init(vec, indexVec);
		meshRenderer->SetMesh(mesh);
	}

	{
		shared_ptr<Shader> shader = make_shared<Shader>();
		shared_ptr<Texture> texture = make_shared<Texture>();
		shader->Init(L"..\\Resources\\Shader\\default.hlsli");
		texture->Init(L"..\\Resources\\Texture\\veigar.jpg");

		shared_ptr<Material> material = make_shared<Material>();
		material->SetShader(shader);
		material->SetFloat(0, 0.3f);
		material->SetFloat(1, 0.4f);
		material->SetFloat(2, 0.3f);
		material->SetTexture(0, texture);
		meshRenderer->SetMaterial(material);
	}

	gameObject->AddComponent(meshRenderer);

	scene->AddGameObject(gameObject);

	return scene;
}
```

ê¸°ì¡´ì— game.cppì—ì„œ ê°€ì§€ê³  ìˆë˜ ê²ƒë“¤ì„ ì—¬ê¸°ì— ì˜®ê¹€.

ê·¸ë¦¬ê³  gameObjectë¥¼ ì „ì—­ì—ì„œ ìŠ¤íƒìœ¼ë¡œ ì˜®ê¸°ê³  ê·¸ê²ƒì„ ê´€ë¦¬í•  Sceneì„ ìƒì„±í•¨.

gameObjectì˜ êµ¬ì„±ì´ ì™„ë£Œ ëë‹¤ë©´ AddGameObjectë¡œ gameObjectë¥¼ ì§‘ì–´ ë„£ê³  sceneì„ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜.

---

### ğŸš€ ì§§ì•„ì§„ game.cpp

```cpp
#include "pch.h"
#include "Game.h"
#include "Engine.h"
#include "SceneManager.h"

void Game::Init(const WindowInfo& info)
{
	GEngine->Init(info);

	GET_SINGLE(SceneManager)->LoadScene(L"TestScene");
}

void Game::Update()
{
	GEngine->Update();
}
```

ê²°ê³¼ì ìœ¼ë¡œ ìš°ë¦¬ëŠ” `GEngine->Init(info);` ì„ í•œ ë’¤ ì”¬ì„ ì„ íƒí•´ì„œ ë¡œë“œê°€ Init.

Updateì—ì„œ `GEngine->Update();` ë§Œ í˜¸ì¶œí•˜ëŠ”ë° 

```cpp
void Engine::Update()
{
	GET_SINGLE(Input)->update();
	GET_SINGLE(Timer)->Update();

	Render();

	ShowFps();
}
```

ì´ë ‡ê²Œ ë³€ê²½ë¨. ì—¬ê¸°ì„œë³´ë©´ Input, Timerë„ ì‹±ê¸€í†¤ìœ¼ë¡œ ë°”ë€ê±¸ ë³¼ ìˆ˜ ìˆìŒ. ì´ê±´ ë‚˜ì¤‘ì— ì„¤ëª….

Renderë„ ë³€ê²½ ì‚¬í•­ì´ ìˆëŠ”ë° ì•„ë˜ì™€ ê°™ìŒ

```cpp
void Engine::Render()
{
	RenderBegin();

	GET_SINGLE(SceneManager)->Update();

	RenderEnd();
}
```

RenderBegin, RenderEnd ì‚¬ì´ì—ëŠ” ì§„ì§œ ê·¸ë¦´ ë¬¼ì²´ë¥¼ ë„£ì–´ì•¼ í–ˆëŠ”ë° ìš°ë¦¬ì˜ SceneManagerì˜ Updateì—ì„œ ëª¨ë“  ê²ƒì„ í•´ì¤Œ.

---

### ğŸš€ Input, Timer Singleton

Input, Timerë¥¼ Manager í•„í„°ë¡œ ì˜®ê¸°ê³  Singletonìœ¼ë¡œ ë³€ê²½í•˜ëŠ” ì‘ì—….
Engineì—ì„œ ì§ì ‘ ë§Œë“¤ì—ˆë˜ ê²ƒë“¤ì„ ëª¨ë‘ ì§€ìš°ê³  `DECLARE_SINGLE`ì„ ì´ìš©í•´ì„œ ì‹±ê¸€í†¤ íŒ¨í„´ìœ¼ë¡œ ë§Œë“ ë‹¤.

ì´ì œ `_input` `_timer` ë¶€ë¶„ë“¤ì€ `GET_SINGLE` ë¡œ ëª¨ë‘ ë°”ê¾¸ë©´ ëœë‹¤.

ì´ ë‹¤ìŒ ì‹œê°„ì€ ì¹´ë©”ë¼ë¥¼ ë§Œë“¤ ê²ƒì¸ë° ì¹´ë©”ë¼ë¥¼ ê³µë¶€í•˜ë ¤ë©´ ì„ ìˆ˜ì§€ì‹ìœ¼ë¡œ ê²Œì„ ìˆ˜í•™ì„ ì•Œì•„ì•¼í•œë‹¤.

ê²Œì„ ìˆ˜í•™ì˜ ë²¡í„°, í–‰ë ¬, ì¢Œí‘œê³„ë¥¼ ì´í•´í•˜ê³  ë„˜ì–´ê°€ì!
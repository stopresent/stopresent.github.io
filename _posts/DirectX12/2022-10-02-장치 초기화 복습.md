---
title: "C++ Rookiss Part2 ê²Œì„ ìˆ˜í•™ê³¼ DirectX12 : Constant Buffer ë³µìŠµ"

categories:
  - DirectX12
tags:
  - DirectX12

author_profile: false

sidebar:
  nav: "docs"

date: 2022-10-05
last_modified_at: 2022-10-05
---

<br>


## ğŸ™‡â€â™€ï¸Constant BUffer


<br>


### ğŸªCPU VS GPU
# 2022_10_04_ì¥ì¹˜ ì´ˆê¸°í™” ì½”ë“œ

---

### ğŸš€ í”„ë¡œì íŠ¸ ì„¸íŒ…

DirectX 12 ê³µë¶€ë¥¼ í•˜ê¸° ìœ„í•œ ì¥ì¹˜ ì´ˆê¸°í™”ê¹Œì§€ì˜ ì½”ë“œ.

êµì¬ëŠ” í”Œë­í¬ D.ë£¨ë‚˜ì˜ `DirectX 12ë¥¼ ì´ìš©í•œ 3D ê²Œì„ í”„ë¡œê·¸ë˜ë° ì…ë¬¸` ì„ ì‚¬ìš©í•˜ê³ , ì¸í„°ë„· ê°•ì˜ë¡œëŠ” ì¸í”„ëŸ°ì— Rookissì˜ `[C++ê³¼ ì–¸ë¦¬ì–¼ë¡œ ë§Œë“œëŠ” MMORPG ê²Œì„ ê°œë°œ ì‹œë¦¬ì¦ˆ] Part2: ê²Œì„ ìˆ˜í•™ê³¼ DirectX12` ë¡œ ê³µë¶€í•œë‹¤.

í”„ë¡œì íŠ¸ëŠ” `Windows Desktop Application` ì„ ìƒì„±í•œë‹¤. (ìœˆë„ìš° ì°½ì´ ëœ¨ëŠ” ê²ƒ ê¹Œì§€ ìë™ ì™„ì„±)

ì½”ë“œëŠ” `Client`ì™€ `Engine`ìœ¼ë¡œ ë‚˜ë‰˜ì–´ì ¸ ìˆìœ¼ë©° `Engine`ì€ `Static Library`ì´ë‹¤.

![DirectX_setting](../../assets/images/DirectX_setting.png)

`Static Library`ëŠ” í”„ë¡œì íŠ¸ ì¶”ê°€ ìƒì„±í•  ë•Œ ì„ íƒì„ í•˜ê³  `Client`ì—ì„œ `Engine`ì„ ì‚¬ìš©í•˜ê¸° ìœ„í•´ì„œëŠ” `Client` ì†ì„±ì—ì„œ `Engine.h`ì™€ `Engine.lib`ì„ ì—°ê²°í•´ì£¼ê³  `link`ê¹Œì§€ í•´ì¤˜ì•¼ í•œë‹¤.

![Hear_Lib_Link](../../assets/images/Hear_Lib_Link.png)

`Include Directories` ì—ëŠ” `h`íŒŒì¼ì„ ë„£ì–´ì£¼ê³  `Library Directories` ì—ëŠ” `lib`íŒŒì¼ì„ ë„£ì–´ì¤˜ì•¼ í•œë‹¤.

`link`ëŠ” ì†ì„±ì—ì„œ ì¶”ê°€ í•  ìˆ˜ ìˆì§€ë§Œ ë³´í†µ `#pragma comment(lib, "Engine.lib")` ì„ ì‚¬ìš©í•œë‹¤. ìœ„ì— ê³¼ì •ì€ `lib` ê°€ ì–´ë”” ìˆëŠ”ì§€ ì•Œë ¤ì£¼ëŠ” ê²ƒì´ê³  ì§ì ‘ì ì¸ ì—°ê²°ì€ `pragma comment` ê°€ í•œë‹¤ê³  ìƒê°í•˜ë©´ ëœë‹¤.

 

ì°¸ê³ ë¡œ ë¹Œë“œ í›„ ë‚˜ì˜¨ ê²°ê³¼ë¬¼ ì¦‰, `Engine.lib`ì™€ `Client.exe`íŒŒì¼ì€ `Output`í´ë”ì— ë‚˜ì˜¤ë„ë¡ ì„¤ì •í–ˆë‹¤.

![Output_setting](../../assets/images/Output_setting.png)

`Output Directory`ì— ê²½ë¡œë¥¼ ì„¤ì •í•˜ëŠ”ê²Œ ì²¨ì–¸í•˜ìë©´ ìƒëŒ€ì ì¸ ê²½ë¡œë¡œ ì„¤ì •í•´ì•¼ ì¢‹ê¸°ì— `$(SolutionDir)`ì—ì„œ `Output`í´ë”ë¡œ ì„¤ì •í–ˆë‹¤. `$(SolutionDir)`ëŠ” í”„ë¡œì íŠ¸ ì†”ë£¨ì…˜ íŒŒì¼ ì¦‰, `sln`íŒŒì¼ì´ ìˆëŠ” í´ë”ë¥¼ ë§í•œë‹¤.

---

### ğŸš€ PCH

`PreCompiled Header` ì˜ ì•½ìë¡œ ê°ì¢… í—¤ë”íŒŒì¼ì„ ëª¨ì•„ ë†“ê³  ì‚¬ìš©ê°€ëŠ¥í•˜ë‹¤.

`Client`ì™€ `Engine`ëª¨ë‘ ì‚¬ìš© í•  ê²ƒì´ë¯€ë¡œ ë‘˜ ë‹¤ ì¶”ê°€ í•´ì¤˜ì•¼í•œë‹¤.

![UsePCH](../../assets/images/UsePCH.png)

`Precompiled Header`ë¥¼ ì‚¬ìš©ì„ ë°”ê¾¸ê³  íŒŒì¼ ì´ë¦„ì„ ì›í•˜ëŠ” ì´ë¦„ìœ¼ë¡œ ì •í•˜ë©´ ë˜ëŠ”ë° `Precompiled Header`ì˜ ì•½ìì¸ `pch`ë¡œ ì •í–ˆë‹¤.

![Make_PCH](../../assets/images/Make_PCH.png)

`pch` í´ë˜ìŠ¤ë¥¼ ìƒì„±í•˜ê³  `cpp`ì— ì†ì„±ì—ì„œ `Use`ê°€ ì•„ë‹ˆë¼ `Create`ë¡œ ì„¤ì •í•´ì¤˜ì•¼í•œë‹¤.

ì´ë ‡ê²Œ ë˜ë©´ `pch` ì‚¬ìš© ì¤€ë¹„ëŠ” ëë‚œë‹¤.

**pch.hëŠ” ëª¨ëŠ” cppíŒŒì¼ì—ì„œ ì‚¬ìš©í•´ì•¼ í•˜ê³  ë¬´ì¡°ê±´ ì²« ì¤„ì— ì ì–´ì•¼ í•œë‹¤.**

---

### ğŸš€ í”„ë¡œì íŠ¸ ì„¸íŒ…

í”„ë¡œì íŠ¸ ì„¸íŒ…ìœ¼ë¡œ `pch` íŒŒì¼ ì¶”ê°€ì™€ `EnginePch, d3dx12, Game class` ì¶”ê°€ê°€ ìˆë‹¤.

ë¨¼ì € `Engine`ë¶€í„° ë§Œë“¤ì–´ë³´ì.

1. **pch**

```cpp
// pch.h

#ifndef PCH_H
#define PCH_H

// ì—¬ê¸°ì— ë¯¸ë¦¬ ì»´íŒŒì¼í•˜ë ¤ëŠ” í—¤ë” ì¶”ê°€
#define WIN32_LEAN_AND_MEAN // ê±°ì˜ ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ë‚´ìš©ì„ Windows í—¤ë”ì—ì„œ ì œì™¸í•©ë‹ˆë‹¤.

#include "EnginePch.h"

#endif //PCH_H
```

ì—¬ê¸°ì—ì„œ ë³¼ê±´ `#include "EnginePch.h"` ë¶€ë¶„ì´ë‹¤ `EnginePch` ë¥¼ ë”°ë¡œ ëº¸ê±¸ ë³¼ ìˆ˜ ìˆëŠ”ë° ë‹¤ë¥¸ `#ifdef` ë“±ë“±ê³¼ ì„ì´ì§€ ì•Šê²Œ ê¹”ë”í•˜ê²Œ ë‚´ê°€ ì‚¬ìš©í•˜ëŠ” ê²ƒë“¤ë§Œ ëª¨ìœ¼ë ¤ê³  ë”°ë¡œ ëºë‹¤.

`pch.cpp`ì—ì„œëŠ” `#include pch.h` ë§Œ ë„£ê³  ì•„ë¬´ê²ƒë„ ì—†ë‹¤.

1. **d3dx12**

`d3dx12.h` ëŠ” ë§ˆì´í¬ë¡œì†Œí”„íŠ¸ì—ì„œ ì§€ì›í•˜ëŠ” `directX helper` íŒŒì¼ì´ë‹¤. ì‚¬ìš©í•˜ê¸° ìœ„í•´ì„œëŠ” êµ¬ê¸€ì— ê²€ìƒ‰ í›„ githubì—ì„œ íŒŒì¼ì„ ë‹¤ìš´ ë°›ê³  ë‚´ í”„ë¡œì íŠ¸ì— ì‚½ì…í•˜ë©´ ëœë‹¤.

1. **EnginePch**

```cpp
// EnginePch.h

#pragma once

// ê°ì¢… include
#include <windows.h>
#include <tchar.h>
#include <memory>
#include <string>
#include <vector>
#include <array>
#include <list>
#include <map>
using namespace std;

#include "d3dx12.h"
#include <d3d12.h>
#include <wrl.h>
#include <d3dcompiler.h>
#include <dxgi.h>
#include <DirectXMath.h>
#include <DirectXPackedVector.h>
#include <DirectXColors.h>
using namespace DirectX;
using namespace DirectX::PackedVector;
using namespace Microsoft::WRL;

// ê°ì¢… lib
#pragma comment(lib, "d3d12")
#pragma comment(lib, "dxgi")
#pragma comment(lib, "dxguid")
#pragma comment(lib, "d3dcompiler")

// ê°ì¢… typedef
using int8		= __int8;
using int16		= __int16;
using int32		= __int32;
using int64		= __int64;
using uint8		= unsigned __int8;
using uint16	= unsigned __int16;
using uint32	= unsigned __int32;
using uint64	= unsigned __int64;
using Vec2		= XMFLOAT2;
using Vec3		= XMFLOAT3;
using Vec4		= XMFLOAT4;
using Matrix	= XMMATRIX;

enum
{
	SWAP_CHAIN_BUFFER_COUNT = 2,
};

struct WindowInfo
{
	HWND	hwnd;
	uint32	width;
	uint32	height;
	bool	windowed;
};

#define DEVICE GEngine->GetDevice()->GetDevice()
#define CMD_LIST GEngine->GetCmdQueue()->GetCmdList()

extern unique_ptr<class Engine> GEngine;
```

```cpp
// EnginePch.cpp

#include "pch.h"
#include "EnginePch.h"
#include "Engine.h"

unique_ptr<Engine> GEngine = make_unique<Engine>();
```

í—¤ë”íŒŒì¼ì—ì„œ ê°ì¢… í¸ë¦¬í•˜ê²Œ ë‹¤ë¥¸ í—¤ë”íŒŒì¼ì„ ë„£ì€ê²ƒê³¼ ë§í¬ì‹œì¼œì£¼ê¸°ê°€ ìˆê³  `using` ì„ ì‚¬ìš©í•œ `typedef` ì´ ìˆë‹¤. ë˜, `enum` ê³¼ `struct WindowInfo` ëŠ” ë‚˜ì¤‘ì— í•„ìš”í•œ ê²ƒë“¤ì´ê³  `#define` ìœ¼ë¡œ ë§¤í¬ë¡œ í•¨ìˆ˜ê¹Œì§€ ìˆë‹¤. ë§ˆì§€ë§‰ìœ¼ë¡œ `unique_ptr` ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°ë¡œ Engineì„ ì „ì—­ìœ¼ë¡œ ë“¤ê³  ìˆê²Œ ë§Œë“¤ì—ˆë‹¤.

ì „ì—­ì¸ê±´ `EnginePch.cpp`ì—ì„œ ì „ì—­ë³€ìˆ˜ë¡œ ë§Œë“ ê±¸ ì•Œ ìˆ˜ ìˆë‹¤.

- **unique_ptr ìŠ¤ë§ˆíŠ¸í¬ì¸í„° ë³µìŠµ**
    
    [https://learn.microsoft.com/ko-kr/cpp/cpp/how-to-create-and-use-unique-ptr-instances?view=msvc-170](https://learn.microsoft.com/ko-kr/cpp/cpp/how-to-create-and-use-unique-ptr-instances?view=msvc-170) (ë§ˆì†Œ ê³µì‹ í•™ìŠµì¥)
    
     `unique_ptr`ì€ í¬ì¸í„°ë¥¼ ê³µìœ í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë‹¤ë¥¸Â `unique_ptr`í•¨ìˆ˜ì— ë³µì‚¬í•˜ê±°ë‚˜, ê°’ìœ¼ë¡œ í•¨ìˆ˜ì— ì „ë‹¬í•˜ê±°ë‚˜, ë³µì‚¬ë³¸ì„ ìƒì„±í•´ì•¼ í•˜ëŠ” C++ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì•Œê³ ë¦¬ì¦˜ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.  ë§ê·¸ëŒ€ë¡œ ë…ë¦½ì ì¸ ìŠ¤ë§ˆíŠ¸í¬ì¸í„°ì´ë‹¤.
    
    1. **ì¸ìŠ¤í„´ìŠ¤ ìƒì„±ê³¼ í•¨ìˆ˜ì‚¬ì´ì—ì„œì˜ ì „ë‹¬**
    
    ```cpp
    unique_ptr<Song> SongFactory(const std::wstring& artist, const std::wstring& title)
    {
        // Implicit move operation into the variable that stores the result.
        return make_unique<Song>(artist, title);
    }
    
    void MakeSongs()
    {
        // Create a new unique_ptr with a new object.
        auto song = make_unique<Song>(L"Mr. Children", L"Namonaki Uta");
    
        // Use the unique_ptr.
        vector<wstring> titles = { song->title };
    
        // Move raw pointer from one unique_ptr to another.
        unique_ptr<Song> song2 = std::move(song);
    
        // Obtain unique_ptr from function that returns by value.
        auto song3 = SongFactory(L"Michael Jackson", L"Beat It");
    }
    ```
    
    1. **ì¸ìŠ¤í„´ìŠ¤ ìƒì„±ê³¼ ë²¡í„°ì—ì„œì˜ ì‚¬ìš©**
    
    ```cpp
    void SongVector()
    {
        vector<unique_ptr<Song>> songs;
        
        // Create a few new unique_ptr<Song> instances
        // and add them to vector using implicit move semantics.
        songs.push_back(make_unique<Song>(L"B'z", L"Juice")); 
        songs.push_back(make_unique<Song>(L"Namie Amuro", L"Funky Town")); 
        songs.push_back(make_unique<Song>(L"Kome Kome Club", L"Kimi ga Iru Dake de")); 
        songs.push_back(make_unique<Song>(L"Ayumi Hamasaki", L"Poker Face"));
    
        // Pass by const reference when possible to avoid copying.
        for (const auto& song : songs)
        {
            wcout << L"Artist: " << song->artist << L"   Title: " << song->title << endl; 
        }    
    }
    ```
    
    1. **í´ë˜ìŠ¤ ë©¤ë²„ì¸ `unique_ptr` ì´ˆê¸°í™”**
    
    ```cpp
    class MyClass
    {
    private:
        // MyClass owns the unique_ptr.
        unique_ptr<ClassFactory> factory;
    public:
    
        // Initialize by using make_unique with ClassFactory default constructor.
        MyClass() : factory (make_unique<ClassFactory>())
        {
        }
    
        void MakeClass()
        {
            factory->DoSomething();
        }
    };
    ```
    

![Utils_setting](../../assets/images/Utils_setting.png)

`Utils` í•„í„°ì— ë¶„ë¥˜í–ˆë‹¤.

---

### ğŸš€ Engine ë¶€í’ˆ ë§Œë“¤ê¸°

ì¥ì¹˜ ì´ˆê¸°í™”ì—ì„œì˜ `Engine`ì˜ ë¶€í’ˆì€  `Engine, Device, CommandQueue, SwapChain, Engine` ì´ ìˆë‹¤.

í•˜ë‚˜í•˜ë‚˜ì˜ `hì™€ cpp` ì„ ë³µë¶™í•˜ê³  ë¶€ê°€ì ì¸ ì„¤ëª…ì„ í•˜ê² ë‹¤. `DirectX` ëŠ” ì „ì²´ê°€ ë§ë¬¼ë ¤ì„œ ê³µë¶€í•´ì•¼ë˜ë¯€ë¡œ ì•„ì§ ì„¤ëª…í•˜ì§€ ì•Šì€ ë¶€ë¶„ì´ë¼ë„ ì•„ëŠ”ê²ƒì²˜ëŸ¼ ì„¤ëª… í•  ê²ƒì´ë‹¤.

1. **Engine**

```cpp
#pragma once

#include "Device.h"
#include "CommandQueue.h"
#include "SwapChain.h"

class Engine
{
public:
	void Init(const WindowInfo& info);
	void Render();

public:
	shared_ptr<Device> GetDevice() { return _device; }
	shared_ptr<CommandQueue> GetCmdQueue() { return _cmdQueue; }
	shared_ptr<SwapChain> GetSwapChain() { return _swapChain; }

public:
	void RenderBegin();
	void RenderEnd();
	
	void ResizeWindow(uint32 width, uint32 height);
private:
	WindowInfo		_window;
	D3D12_VIEWPORT	_viewport = {};
	D3D12_RECT		_scissorRect = {};

	shared_ptr<Device>			_device = make_shared<Device>();
	shared_ptr<CommandQueue>	_cmdQueue = make_shared<CommandQueue>();
	shared_ptr<SwapChain>		_swapChain = make_shared<SwapChain>();
};
```

í—¤ë”íŒŒì¼ì— í—¤ë”íŒŒì¼ì„ ë„£ëŠ” ê²ƒì€ ì¢‹ì§€ ì•Šì€ ìŠµê´€ì´ì§€ë§Œ í¸ë¦¬í•¨ì„ ìœ„í•´ì„œ ë„£ì—ˆë‹¤. ì´ë ‡ê²Œí•˜ë©´ `Engine.h`ë§Œ ì¶”ê°€í•´ë„ ë‚˜ë¨¸ì§€ í—¤ë”íŒŒì¼ì„ ì‚¬ìš© í•  ìˆ˜ ìˆë‹¤.

`Device, CommandQueue, SwapChain`ì„ ë©¤ë²„ ë³€ìˆ˜ë¡œ ë“¤ê³  ìˆìœ¼ë©° ìƒì„±ë„ í•œë‹¤. ë˜, `Get`ìœ¼ë¡œ ëª¨ë‘ ë¹¼ì˜¬ìˆ˜ ìˆê²Œ ë§Œë“¤ì—ˆë‹¤. ì´ë ‡ê²Œ í•œë‹¤ë©´ í”„ë¡œì íŠ¸ ì„¸íŒ… ë•Œ `unique_ptr GEngine` ì¸ ì „ì—­ `Engine` ìœ¼ë¡œ ëª¨ë‘ ë¹¼ì˜¬ìˆ˜ ìˆë‹¤ëŠ” í¸ë¦¬í•¨ì´ ìƒê¸´ë‹¤.

ì°½ ì„¤ì •ì— í•„ìš”í•œ `WindowInfo _window;` `D3D12_VIEWPORT	_viewport = {};` `D3D12_RECT _scissorRect = {};` ì„ ë©¤ë²„ ë³€ìˆ˜ë¡œ ë“¤ê³  ìˆë‹¤.

`Init, Render, RenderBegin, RenderEnd, ResizeWindow` í•¨ìˆ˜ê°€ ìˆìœ¼ë©° `RenderBegin, RenderEnd` ì€ `CommandQueue` ë¥¼ í†µí•´ì„œ ì‚¬ìš©í•˜ê²Œ ëœë‹¤. `ResizeWindow` ëŠ” í˜¹ì‹œë¼ë„ ì°½ ì‚¬ì´ì¦ˆë¥¼ ë°”ê¿€ ìˆ˜ ìˆìœ¼ë‹ˆ ë§Œë“¤ì–´ì§„ í•¨ìˆ˜ì´ê³  ì…ë ¥ì— ë”°ë¼ ë³€í•˜ê²Œ ì¸ìë¥¼ ë°›ëŠ”ë‹¤.

 

```cpp
#include "pch.h"
#include "Engine.h"

void Engine::Init(const WindowInfo& info)
{
	_window = info;
	ResizeWindow(info.width, info.height);

	_viewport = { 0, 0, static_cast<FLOAT>(info.width), static_cast<FLOAT>(info.height), 0.0f, 1.0f };
	_scissorRect = CD3DX12_RECT(0, 0, info.width, info.height);

	_device->Init();
	_cmdQueue->Init(_device->GetDevice(), _swapChain);
	_swapChain->Init(info, _device->GetDevice(), _device->GetDXGI(), _cmdQueue->GetCmdQueue());
}

void Engine::Render()
{
	RenderBegin();

	// TODO Reder

	RenderEnd();
}

void Engine::RenderBegin()
{
	_cmdQueue->RenderBegin(&_viewport, &_scissorRect);
}

void Engine::RenderEnd()
{
	_cmdQueue->RenderEnd();
}

void Engine::ResizeWindow(uint32 width, uint32 height)
{
	_window.width = width;
	_window.height = height;

	RECT rect = { 0, 0, width, height };
	::AdjustWindowRect(&rect, WS_OVERLAPPEDWINDOW, false);
	::SetWindowPos(_window.hwnd, 0, 100, 100, width, height, 0);
}
```

`Init` ì—ì„œ ì°¸ì¡°ê°’ìœ¼ë¡œ `WindowInfo` ë¥¼ ë°›ê³  ìˆë‹¤. (ì§„í‰ìœ¼ë¡œ ì‘ì—…) ë©¤ë²„ ë³€ìˆ˜ë¥¼ ëŒ€ì…í•´ì£¼ê³  ì…ë ¥ëœ `info` ì˜ `width height` ë¡œ `ResizeWindow` ë¥¼ í•´ì¤€ë‹¤. `_viewport _scissorRect` ëŠ” ì›í•˜ëŠ” ì¸ìì— ë§ê²Œ ëŒ€ì…í•œ ê²ƒì´ê³  ê·¸ ë’¤ì— ë©¤ë²„ë³€ìˆ˜ë¡œ ë“¤ê³  ìˆë˜ `Device, CommandQueue, SwapChain` ì˜ `Init` í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•œë‹¤. ì´ë ‡ê²Œ í•˜ë©´ `Engine` ì˜ `Init` ë§Œ í•˜ë©´ ë‚˜ë¨¸ì§€ë„ ìë™ìœ¼ë¡œ ëœë‹¤.

ë‚˜ë¨¸ì§€ëŠ” ê·¸ëƒ¥ ê·¸ë ‡ë‹¤.

1. **Device**

```cpp
#pragma once

class Device
{
public:
	void Init();

	ComPtr<IDXGIFactory> GetDXGI() { return _dxgi; }
	ComPtr<ID3D12Device> GetDevice() { return _device; }

private:
	ComPtr<ID3D12Debug>		_debugController;
	ComPtr<IDXGIFactory>	_dxgi;
	ComPtr<ID3D12Device>	_device;

};
```

`Init`í•¨ìˆ˜ì™€ ë©¤ë²„ ë³€ìˆ˜ ëº´ì˜¬ìˆ˜ìˆëŠ” í•¨ìˆ˜ê°€ ìˆë‹¤.

`ComPtr<ID3D12Debug> _debugController;` ëŠ” ë””ë²„ê·¸ìš©ìœ¼ë¡œ ìˆëŠ”ê²ƒ.

`ComPtr<IDXGIFactory> _dxgi;` ëŠ” ì‹¤ì§ˆì ìœ¼ë¡œ ê·¸ë¦´ í™”ë©´ê³¼ ê´€ë ¨ ë¼ìˆë‹¤.

`ComPtr<ID3D12Device> _device;` ë””ë°”ì´ìŠ¤ëŠ” ë“¤ê³  ìˆì–´ì•¼ ëœë‹¤.

- **ComPtr ê³¼ IDXGIFactory**
    1. **ComPtr**
    
    `ComPtr` ê°ì²´ëŠ” `Component Object Model Pointer` ì˜ ì•½ìë¡œ `DirectX` ì˜ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ ë…ë¦½ì„±ê³¼ í•˜ìœ„ í˜¸í™˜ì„±ì„ ê°€ëŠ¥í•˜ê²Œ í•˜ëŠ” ê¸°ìˆ ì´ë‹¤. ì´ê²Œ ë¬´ìŠ¨ ë§ì´ëƒë©´ ì‰½ê²Œ ë§í•´ì„œ ê·¸ë˜í”½ ì¹´ë“œë¥¼ ì‚¬ìš©í•˜ê²Œ í•˜ëŠ” ì–¸ì–´ë‹¤.  ë§ˆì†ŒëŠ” ê·¸ë˜í”½ ì¹´ë“œë¥¼ ë‹¤ë¥¸ íšŒì‚¬ê±¸ ì‚¬ìš©í•˜ëŠ”ë° ê·¸ë˜í”½ ì¹´ë“œì˜ ì–¸ì–´ëŠ” íšŒì‚¬ë§ˆë‹¤ ë‹¤ë¥´ì§€ë§Œ ë§ˆì†Œì—ì„œ ì •í•´ ë†“ì€ ê·œê²©, ì–¸ì–´ë¡œ í†µì¼í™”í•´ì„œ ìš°ë¦¬ëŠ” ê°ê°ì˜ ê·¸ë˜í”½ ì–¸ì–´ë¥¼ ì•Œ í•„ìš”ê°€ ì—†ë‹¤. `DirectX` ëŠ” ê·¸ëŸ° ìš©ë„ì´ê³  `ComPtr` ì€ ê·¸ë ‡ê²Œ í•˜ëŠ” ë„êµ¬ë¼ê³  ìƒê°í•˜ì.
    
    1. **IDXGIFactory**
    
    `ComPtr` ì¸í„°í˜ì´ìŠ¤ë“¤ì€ `I` ê°€ ë¶™ëŠ”ë‹¤.  `DXGI` ëŠ” `DirectX Graphics Infrastructure` ì˜ ì•½ìë¡œ `Direct3D` ì™€ í•¨ê»˜ ì“°ì´ëŠ” APIì´ë‹¤. ì´ê²ƒì€ ì—¬ëŸ¬ ê·¸ë˜í”½ APIë“¤ì— ê³µí†µì¸ ê·¸ë˜í”½ ê´€ë ¨ ì‘ì—…ë“¤ì´ ì¡´ì¬í•œë‹¤. `IDXGISwapChain` ì¸í„°í˜ì´ìŠ¤ ìƒì„±ê³¼ ë””ìŠ¤í”Œë ˆì´ ì–´ëŒ‘í„° ì—´ê±°ì— ì“°ì¸ë‹¤.
    

```cpp
#include "pch.h"
#include "Device.h"

void Device::Init()
{
#ifdef DEBUG
	::D3D12GetDebugInterface(IID_PPV_ARGS(&_debugController));
	_debugController->EnableDebugLayer();
#endif // DEBUG

	::CreateDXGIFactory(IID_PPV_ARGS(&_dxgi));

	::D3D12CreateDevice(nullptr, D3D_FEATURE_LEVEL_11_0, IID_PPV_ARGS(&_device));
}
```

ì²˜ìŒì— ë‚˜ì˜¤ëŠ” í•¨ìˆ˜ëŠ” ë””ë²„ê·¸ìš©ìœ¼ë¡œ ì±…ì—ì„œ ë‚˜ì˜¨ê±°ë‘ ë˜‘ê°™ì´ ì ì€ê±°ë‹¤.

ê·¸ ë’¤ ë‚˜ì˜¤ëŠ” `::CreateDXGIFactory(IID_PPV_ARGS(&_dxgi));` ë¡œ í™”ë©´ê´€ë ¨ ì‚¬ìš©í• ê²ƒë“¤ì„ ë§Œë“ ë‹¤.

ì¸ìë¡œ `IID_PPV_ARGS(&_dxgi)` ë¥¼ ë°›ëŠ”ë° `IID_PPV_ARGS` ëŠ” ë§¤í¬ë¡œë¡œì¨ `#define IID_PPV_ARGS(ppType) __uuidof(**(ppType)), IID_PPV_ARGS_Helper(ppType)` ì´ë ‡ê²Œ ë§ˆì†Œì—ì„œ ë§Œë“  ë§¤í¬ë¡œì¸ê±¸ ì•Œ ìˆ˜ ìˆë‹¤. ë±‰ëŠ” ê²ƒì€ `riid : ë””ë°”ì´ìŠ¤ì˜ COM ID`, `ppDevice : ìƒì„±ëœ ì¥ì¹˜ê°€ ë§¤ê°œë³€ìˆ˜ì— ì„¤ì •` ì„ ë±‰ëŠ”ë‹¤.

`D3D12CreateDevice` ì—ì„œëŠ” ì–´ëŒ‘í„° í¬ì¸í„°ì™€ ìµœì†Œìˆ˜ì¤€ë ˆë²¨ IID_PPV_ARGSë¥¼ ë°›ëŠ”ë‹¤. ì–´ëŒ‘í„°ëŠ” `nullptr` ì´ë‹¤. ìµœì†Œìˆ˜ì¤€ë ˆë²¨ì´ë€ ì‚¬ìš©ìê°€ ìµœì†Œí•œ ì´ì •ë„ëŠ” ë˜ì•¼ëœë‹¤ ì¸ë° ê·¸ë˜í”½ì¹´ë“œì˜ ìˆ˜ì¤€ì„ ë§í•œë‹¤. ê·¸ë˜í”½ì¹´ë“œê°€ ìµœì†Œí•œ directX11ê¹Œì§€ëŠ” ì§€ì›í•´ì•¼ í”„ë¡œê·¸ë¨ì´ ëŒì•„ê°„ë‹¤ëŠ” ëœ»ì´ë‹¤.

1. **CommandQueue**

```cpp
#pragma once

class CommandQueue
{
public:
	~CommandQueue();

	void Init(ComPtr<ID3D12Device> device, shared_ptr<class SwapChain> swapChain);
	void WaitSync();

	void RenderBegin(const D3D12_VIEWPORT* vp, const D3D12_RECT* rect);
	void RenderEnd();

	ComPtr<ID3D12CommandQueue> GetCmdQueue() { return _cmdQueue; }
	ComPtr<ID3D12GraphicsCommandList> GetCmdList() { return _cmdList; }

private:
	ComPtr<ID3D12CommandQueue>		_cmdQueue;
	ComPtr<ID3D12CommandAllocator>	_cmdAlloc;
	ComPtr<ID3D12GraphicsCommandList>		_cmdList;

	ComPtr<ID3D12Fence>					_fence;
	uint32								_fenceValue = 0;
	HANDLE								_fenceEvent = INVALID_HANDLE_VALUE;

	shared_ptr<class SwapChain>			_swapChain;
};
```

`DX12`ë¶€í„° ë‚˜ì˜¨ ê°œë…ìœ¼ë¡œ ì¼ê°ë“¤ì„ `Queue`ì— ìŒ“ì•„ ë†“ê³  ë‚˜ì¤‘ì— í•œêº¼ë²ˆì— ì¼ì„ ë§¡ê¸°ëŠ” ë°©ì‹ì´ë‹¤.

`RenderBegin`ìœ¼ë¡œ ì¼ê°ë“¤ì„ ë°›ê¸° ì‹œì‘í•˜ê³  `RenderEnd`ë¡œ ì¼ê° ë°›ëŠ” ë¬¸ì„ ë‹«ê³  ì¼ì„ ë„˜ê¸´ë‹¤.

ì—¬ê¸°ì„œ `ID3D12CommandQueue, ID3D12CommandAllocator, ID3D12GraphicsCommandList`ëŠ” í•œ ì„¸íŠ¸ë¼ê³  ìƒê°í•˜ë©´ ëœë‹¤.

`Fence`ëŠ” ë™ê¸°í™”ë¥¼ ìœ„í•œ ì‘ì—…ìœ¼ë¡œ ì¼ê°ë“¤ì„ ë°›ì•„ ë“¤ì´ê³  ìˆì„ ë–„ (read) ì¼ê°ë“¤ì„ ì‚¬ìš©í•˜ëŠ”ê²ƒ(write)ì´ ë¶ˆê°€ëŠ¥í•˜ê²Œ ë˜ì–´ìˆë‹¤. `Fence`ëŠ” ì´ëŸ° ìƒí™©ì„ ë°©ì§€ í•˜ë„ë¡ `GPU`ì˜ ì‘ì—…ì´ ë‹¤ ëë‚  ë•Œ ê¹Œì§€ëŠ” `CPU`ê°€ ê°€ë§Œíˆ ìˆë„ë¡ ë§Œë“ ë‹¤. ë¬¼ë¡  ì¢‹ì€ ë°©ë²•ì€ ì•„ë‹ˆë‹¤.

```cpp
#include "pch.h"
#include "CommandQueue.h"
#include "SwapChain.h"

CommandQueue::~CommandQueue()
{
	::CloseHandle(_fenceEvent);
}
// ì†Œë©¸ì ìƒì„±ì‹œ fenceEvent êº¼ì£¼ê¸°

void CommandQueue::Init(ComPtr<ID3D12Device> device, shared_ptr<class SwapChain> swapChain)
{
	_swapChain = swapChain;

	D3D12_COMMAND_QUEUE_DESC queueDesc = {};
	queueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;
	queueDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;

	device->CreateCommandQueue(&queueDesc, IID_PPV_ARGS(&_cmdQueue));

	device->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&_cmdAlloc));

	device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, _cmdAlloc.Get(), nullptr, IID_PPV_ARGS(&_cmdList));

	_cmdList->Close();

	device->CreateFence(_fenceValue, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&_fence));
	_fenceEvent = ::CreateEvent(nullptr, FALSE, FALSE, nullptr);
}

// ë©¤ë²„ë³€ìˆ˜ swapChain ë„£ê¸°
// CreateCommandQueueë¥¼ í•˜ê¸° ìœ„í•œ D3D12_COMMAND_QUEUE_DESC ì‘ì„±
// CreateCommandAloocatorì™€ CreateCommandListë¡œ ì„¸íŠ¸ ìƒì„±
// ì´ ë•Œ ìƒì„±ì€ deviceì—ì„œ ì¶œë°œí•œë‹¤. deviceëŠ” ComPtrë¡œ ë°›ê³ ìˆìŒ
// ì´ë ‡ê²Œ ì„¸íŠ¸ë¥¼ ë§Œë“¤ê³  ì„¤ì •í•˜ë©´ cmdListì—ì„œ closeë¥¼ í•´ì•¼ ë¨
// ê·¸ í›„ fenceì™€ fenceEventë¥¼ ë§Œë“¤ì—ˆìŒ

void CommandQueue::WaitSync()
{
	_fenceValue++;

	_cmdQueue->Signal(_fence.Get(), _fenceValue);

	if (_fence->GetCompletedValue() < _fenceValue)
	{
		_fence->SetEventOnCompletion(_fenceValue, _fenceEvent);

		::WaitForSingleObject(_fenceEvent, INFINITE);
	}
}
// ì—¬ê¸°ì„œì˜ ì£¼ëœ ì‘ì—…ì€ ì¼ê° ê¸°ë‹¤ë¦¬ê¸°ì´ë‹¤.
// fenceValue++ : ê¸°ë‹¤ë¦´ ì¼ê° ì¶”ê°€
// Signal : ì‹ í˜¸ëŒ€ê¸°ì¤‘
// ì¼ê° ëë‚˜ë©´ ì™„ë£Œ!

void CommandQueue::RenderBegin(const D3D12_VIEWPORT* vp, const D3D12_RECT* rect)
{
	_cmdAlloc->Reset();
	_cmdList->Reset(_cmdAlloc.Get(), nullptr);

	D3D12_RESOURCE_BARRIER barrier = CD3DX12_RESOURCE_BARRIER::Transition(
		_swapChain->GetCurrentBackBufferResource().Get(),
		D3D12_RESOURCE_STATE_PRESENT, // í™”ë©´ ì¶œë ¥
		D3D12_RESOURCE_STATE_RENDER_TARGET); // ì™¸ì£¼ ê²°ê³¼ë¬¼

	_cmdList->ResourceBarrier(1, &barrier);

	// Set the viewport and scissor rect.  This needs to be reset whenever the command list is reset.
	_cmdList->RSSetViewports(1, vp);
	_cmdList->RSSetScissorRects(1, rect);

	// Specify the buffers we are going to render to.
	D3D12_CPU_DESCRIPTOR_HANDLE backBufferView = _swapChain->GetBackRTV();
	_cmdList->ClearRenderTargetView(backBufferView, Colors::LightSteelBlue, 0, nullptr);
	_cmdList->OMSetRenderTargets(1, &backBufferView, FALSE, nullptr);
}
// cmdAlloc, cmdListë¥¼ ì´ˆê¸°í™”
// barrierë¥¼ ìƒì„±í•˜ëŠ”ë° ì¸ìë¥¼ ìì„¸íˆ ë³´ë©´ swapChainì—ì„œ í˜„ì¬ BackBufferRescoureë¥¼ ê°€ì ¸ì˜¤ê³ 
// í˜„ì¬ í™”ë©´ê³¼ ë’·í™”ë©´ì„ ì¸ìë¡œ ë°›ëŠ”ë‹¤.
// ì•Œë§ì€ ì¸ì ì„¸íŒ… í›„ í™”ë©´ì˜ viewPortì™€ scissorRectë¥¼ ë‹¤ì‹œ ì„¸íŒ…í•œë‹¤.
// ì´ë ‡ê²Œ í•˜ë©´ ë¬¸ì€ ì—´ë¦°ê±°ê³  ì´ì œ ì‘ì—…ì„ ë„£ëŠ”ë° swapChainì—ì„œ BackRenderTargetViewë¥¼ ê°€ì ¸ì™€ì„œ
// í™”ë©´ì„ LightSteelBlueìƒ‰ìœ¼ë¡œ ì„¤ì •
// RenderTargetì„ ì„¤ì •

void CommandQueue::RenderEnd()
{
	D3D12_RESOURCE_BARRIER barrier = CD3DX12_RESOURCE_BARRIER::Transition(
		_swapChain->GetCurrentBackBufferResource().Get(),
		D3D12_RESOURCE_STATE_RENDER_TARGET, // ì™¸ì£¼ ê²°ê³¼ë¬¼
		D3D12_RESOURCE_STATE_PRESENT); // í™”ë©´ ì¶œë ¥

	_cmdList->ResourceBarrier(1, &barrier);
	_cmdList->Close();
}
// Beginì—ì„œì™€ ë°˜ëŒ€ë¡œ ë’·í™”ë©´ê³¼ í˜„ì¬í™”ë©´ì„ ë°›ëŠ”ë‹¤.
// swapChainì—ì„œ ë°°ìš´ double bufferingì„ í‘œí˜„í•˜ëŠ” ê²ƒ.
// ë‹¤ì‹œ í™”ë©´ì„ ì„¤ì •í•˜ê³ 
// ì¼ê° ë¬¸ ë‹«ê¸°
```

ë„ˆë¬´ ë§ì•„ì„œ í•¨ìˆ˜ ë°‘ì— ë¶€ê°€ì ì´ ì„¤ëª…ìœ¼ë¡œ ëŒ€ì²´

1. **SwapChain**

```cpp
#pragma once

class SwapChain
{
public:
	void Init(const WindowInfo& info, ComPtr<ID3D12Device> device, ComPtr<IDXGIFactory> dxgi, ComPtr<ID3D12CommandQueue> cmdQueue);
	void Present();
	void SwapIndex();

	ComPtr<IDXGISwapChain> GetSwapChain() { return _swapChain; }
	ComPtr<ID3D12Resource> GetRenderTarget(int32 index) { return _rtvBuffer[index]; }

	uint32 GetBackRTVBuffer() { return _backBufferIndex; }
	ComPtr<ID3D12Resource> GetCurrentBackBufferResource() { return _rtvBuffer[_backBufferIndex]; }

	D3D12_CPU_DESCRIPTOR_HANDLE GetBackRTV() { return _rtvHandle[_backBufferIndex]; }
	

private:
	void CreateSwapChain(const WindowInfo& info, ComPtr<IDXGIFactory> dxgi, ComPtr<ID3D12CommandQueue> cmdQueue);
	void CreateRTV(ComPtr<ID3D12Device> device);

private:
	ComPtr<IDXGISwapChain>			_swapChain;

	ComPtr<ID3D12Resource>			_rtvBuffer[SWAP_CHAIN_BUFFER_COUNT];
	ComPtr<ID3D12DescriptorHeap>	_rtvHeap;
	D3D12_CPU_DESCRIPTOR_HANDLE		_rtvHandle[SWAP_CHAIN_BUFFER_COUNT];

	uint32							_backBufferIndex = 0;
};
```

ì•„ ë”ë¸” ë²„í¼ë§ì€ ì™„ë²½í•˜ê²Œ ì´í•´í–ˆìœ¼ë‹ˆ ìƒëµâ€¦

```cpp
#include "pch.h"
#include "SwapChain.h"

void SwapChain::Init(const WindowInfo& info, ComPtr<ID3D12Device> device, ComPtr<IDXGIFactory> dxgi, ComPtr<ID3D12CommandQueue> cmdQueue)
{
	CreateSwapChain(info, dxgi, cmdQueue);
	CreateRTV(device);
}

void SwapChain::Present()
{
	_swapChain->Present(0, 0);
}

void SwapChain::SwapIndex()
{
	_backBufferIndex = (_backBufferIndex + 1) % SWAP_CHAIN_BUFFER_COUNT;
}

void SwapChain::CreateSwapChain(const WindowInfo& info, ComPtr<IDXGIFactory> dxgi, ComPtr<ID3D12CommandQueue> cmdQueue)
{
	_swapChain.Reset();

	DXGI_SWAP_CHAIN_DESC sd;
	sd.BufferDesc.Width = static_cast<uint32>(info.width); // ë²„í¼ì˜ í•´ìƒë„ ë„ˆë¹„
	sd.BufferDesc.Height = static_cast<uint32>(info.height); // ë²„í¼ì˜ í•´ìƒë„ ë†’ì´
	sd.BufferDesc.RefreshRate.Numerator = 60; // í™”ë©´ ê°±ì‹  ë¹„ìœ¨
	sd.BufferDesc.RefreshRate.Denominator = 1; // í™”ë©´ ê°±ì‹  ë¹„ìœ¨
	sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM; // ë²„í¼ì˜ ë””ìŠ¤í”Œë ˆì´ í˜•ì‹
	sd.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;
	sd.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;
	sd.SampleDesc.Count = 1; // ë©€í‹° ìƒ˜í”Œë§ OFF
	sd.SampleDesc.Quality = 0;
	sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT; // í›„ë©´ ë²„í¼ì— ë Œë”ë§í•  ê²ƒ 
	sd.BufferCount = SWAP_CHAIN_BUFFER_COUNT; // ì „ë©´+í›„ë©´ ë²„í¼
	sd.OutputWindow = info.hwnd;
	sd.Windowed = info.windowed;
	sd.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD; // ì „ë©´ í›„ë©´ ë²„í¼ êµì²´ ì‹œ ì´ì „ í”„ë ˆì„ ì •ë³´ ë²„ë¦¼
	sd.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

	dxgi->CreateSwapChain(cmdQueue.Get(), &sd, &_swapChain);

	for (int32 i = 0; i < SWAP_CHAIN_BUFFER_COUNT; i++)
		_swapChain->GetBuffer(i, IID_PPV_ARGS(&_rtvBuffer[i]));
}

void SwapChain::CreateRTV(ComPtr<ID3D12Device> device)
{

	// Descriptor (DX12) = View (~DX11)
	// [ì„œìˆ ì í™]ìœ¼ë¡œ RTV ìƒì„±
	// DX11ì˜ RTV(RenderTargetView), DSV(DepthStencilView), 
	// CBV(ConstantBufferView), SRV(ShaderResourceView), UAV(UnorderedAccessView)ë¥¼ ì „ë¶€!

	int32 rtvHeapSize = device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);

	D3D12_DESCRIPTOR_HEAP_DESC rtvDesc;
	rtvDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;
	rtvDesc.NumDescriptors = SWAP_CHAIN_BUFFER_COUNT;
	rtvDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
	rtvDesc.NodeMask = 0;

	// ê°™ì€ ì¢…ë¥˜ì˜ ë°ì´í„°ë¼ë¦¬ ë°°ì—´ë¡œ ê´€ë¦¬
	// RTV ëª©ë¡ : [ ] [ ]
	device->CreateDescriptorHeap(&rtvDesc, IID_PPV_ARGS(&_rtvHeap));

	D3D12_CPU_DESCRIPTOR_HANDLE rtvHeapBegin = _rtvHeap->GetCPUDescriptorHandleForHeapStart();

	for (int i = 0; i < SWAP_CHAIN_BUFFER_COUNT; i++)
	{
		_rtvHandle[i] = CD3DX12_CPU_DESCRIPTOR_HANDLE(rtvHeapBegin, i * rtvHeapSize);
		device->CreateRenderTargetView(_rtvBuffer[i].Get(), nullptr, _rtvHandle[i]);
	}
}
```

ì´ë ‡ê²Œ í•˜ë©´ `Engine` ê¸°ë³¸ ë¼ˆëŒ€ ì™„ì„±

![BaseEngine](../../assets/images/BaseEngine.png)

ì—¬ê¸°ì„œ `RootSignature`ë§Œ ì—†ëŠ” ìƒí™©. ì´ì œ `Client`ë¡œ ë„˜ì–´ê°€ì„œ ì‹¤ì œë¡œ ì‚¬ìš©ì„ í•´ì•¼ ë¨.

---

### ğŸš€ Clientì—ì„œ í…ŒìŠ¤íŠ¸

![BaseClient](../../assets/images/BaseClient.png)

êµ¬ì¡°ëŠ” ì´ë ‡ê²Œ ë  ê²ƒì´ë‹¤.

pchëŠ” ì•ì„œ ì„¤ëª…í•œ ê²ƒì²˜ëŸ¼

```cpp
#pragma once

#pragma comment(lib, "Engine.lib")

#include "EnginePch.h"
```

ì´ë ‡ê²Œ ë“¤ê³ ìˆê³  cppíŒŒì¼ë„ `#include "pch.h"` ë§Œ ìˆë‹¤.

ì•Œì•„ë³¼ê²ƒì€ `Game class, Client class`ë§Œ ë¶„ì„ í•  ê²ƒì´ë‹¤.

1. **Client**

```cpp
// Client.cpp : ì• í”Œë¦¬ì¼€ì´ì…˜ì— ëŒ€í•œ ì§„ì…ì ì„ ì •ì˜í•©ë‹ˆë‹¤.
//
#include "pch.h"
#include "framework.h"
#include "Client.h"
#include "Game.h"

#define MAX_LOADSTRING 100

// ì „ì—­ ë³€ìˆ˜:
WindowInfo GWindowInfo; // WindowInfo ë„£ì–´ì¤¬ìŒ

HINSTANCE hInst;                                // í˜„ì¬ ì¸ìŠ¤í„´ìŠ¤ì…ë‹ˆë‹¤.
WCHAR szTitle[MAX_LOADSTRING];                  // ì œëª© í‘œì‹œì¤„ í…ìŠ¤íŠ¸ì…ë‹ˆë‹¤.
WCHAR szWindowClass[MAX_LOADSTRING];            // ê¸°ë³¸ ì°½ í´ë˜ìŠ¤ ì´ë¦„ì…ë‹ˆë‹¤.

// ì´ ì½”ë“œ ëª¨ë“ˆì— í¬í•¨ëœ í•¨ìˆ˜ì˜ ì„ ì–¸ì„ ì „ë‹¬í•©ë‹ˆë‹¤:
ATOM                MyRegisterClass(HINSTANCE hInstance);
BOOL                InitInstance(HINSTANCE, int);
LRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK    About(HWND, UINT, WPARAM, LPARAM);

int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
                     _In_opt_ HINSTANCE hPrevInstance,
                     _In_ LPWSTR    lpCmdLine,
                     _In_ int       nCmdShow)
{
    UNREFERENCED_PARAMETER(hPrevInstance);
    UNREFERENCED_PARAMETER(lpCmdLine);

    // TODO: ì—¬ê¸°ì— ì½”ë“œë¥¼ ì…ë ¥í•©ë‹ˆë‹¤.

    // ì „ì—­ ë¬¸ìì—´ì„ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
    LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
    LoadStringW(hInstance, IDC_CLIENT, szWindowClass, MAX_LOADSTRING);
    MyRegisterClass(hInstance);

    // ì• í”Œë¦¬ì¼€ì´ì…˜ ì´ˆê¸°í™”ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤:
    if (!InitInstance (hInstance, nCmdShow))
    {
        return FALSE;
    }

    HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_CLIENT));

    MSG msg;
// WindowInfo ì¸ì ì„¤ì •
    GWindowInfo.width = 800;
    GWindowInfo.height = 600;
    GWindowInfo.windowed = true;

    unique_ptr<Game> game = make_unique<Game>(); // Game ë“¤ê³ ìˆê¸°
    game->Init(GWindowInfo); // ì‹œì‘

    // ê¸°ë³¸ ë©”ì‹œì§€ ë£¨í”„ì…ë‹ˆë‹¤:
    while (true)
    {
        if (PeekMessage(&msg, nullptr, 0, 0, PM_REMOVE))
        {
            if (msg.message == WM_QUIT)
                break;

			if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg))
			{
				TranslateMessage(&msg);
				DispatchMessage(&msg);
			}
        }

		// TODO
        game->Update(); // ì—…ë°ì´íŠ¸
    }

    return (int) msg.wParam;
}

//
//  í•¨ìˆ˜: MyRegisterClass()
//
//  ìš©ë„: ì°½ í´ë˜ìŠ¤ë¥¼ ë“±ë¡í•©ë‹ˆë‹¤.
//
ATOM MyRegisterClass(HINSTANCE hInstance)
{
    WNDCLASSEXW wcex;

    wcex.cbSize = sizeof(WNDCLASSEX);

    wcex.style          = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc    = WndProc;
    wcex.cbClsExtra     = 0;
    wcex.cbWndExtra     = 0;
    wcex.hInstance      = hInstance;
    wcex.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_CLIENT));
    wcex.hCursor        = LoadCursor(nullptr, IDC_ARROW);
    wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1);
    wcex.lpszMenuName   = nullptr;
    wcex.lpszClassName  = szWindowClass;
    wcex.hIconSm        = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));

    return RegisterClassExW(&wcex);
}

//
//   í•¨ìˆ˜: InitInstance(HINSTANCE, int)
//
//   ìš©ë„: ì¸ìŠ¤í„´ìŠ¤ í•¸ë“¤ì„ ì €ì¥í•˜ê³  ì£¼ ì°½ì„ ë§Œë“­ë‹ˆë‹¤.
//
//   ì£¼ì„:
//
//        ì´ í•¨ìˆ˜ë¥¼ í†µí•´ ì¸ìŠ¤í„´ìŠ¤ í•¸ë“¤ì„ ì „ì—­ ë³€ìˆ˜ì— ì €ì¥í•˜ê³ 
//        ì£¼ í”„ë¡œê·¸ë¨ ì°½ì„ ë§Œë“  ë‹¤ìŒ í‘œì‹œí•©ë‹ˆë‹¤.
//
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
   hInst = hInstance; // ì¸ìŠ¤í„´ìŠ¤ í•¸ë“¤ì„ ì „ì—­ ë³€ìˆ˜ì— ì €ì¥í•©ë‹ˆë‹¤.

   HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,
      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr);

   if (!hWnd)
   {
      return FALSE;
   }

   ShowWindow(hWnd, nCmdShow);
   UpdateWindow(hWnd);
   
   GWindowInfo.hwnd = hWnd; // ì°½ ì„¤ì •

   return TRUE;
}

//
//  í•¨ìˆ˜: WndProc(HWND, UINT, WPARAM, LPARAM)
//
//  ìš©ë„: ì£¼ ì°½ì˜ ë©”ì‹œì§€ë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤.
//
//  WM_COMMAND  - ì• í”Œë¦¬ì¼€ì´ì…˜ ë©”ë‰´ë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤.
//  WM_PAINT    - ì£¼ ì°½ì„ ê·¸ë¦½ë‹ˆë‹¤.
//  WM_DESTROY  - ì¢…ë£Œ ë©”ì‹œì§€ë¥¼ ê²Œì‹œí•˜ê³  ë°˜í™˜í•©ë‹ˆë‹¤.
//
//
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_COMMAND:
        {
            int wmId = LOWORD(wParam);
            // ë©”ë‰´ ì„ íƒì„ êµ¬ë¬¸ ë¶„ì„í•©ë‹ˆë‹¤:
            switch (wmId)
            {
            case IDM_ABOUT:
                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);
                break;
            case IDM_EXIT:
                DestroyWindow(hWnd);
                break;
            default:
                return DefWindowProc(hWnd, message, wParam, lParam);
            }
        }
        break;
    case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hWnd, &ps);
            // TODO: ì—¬ê¸°ì— hdcë¥¼ ì‚¬ìš©í•˜ëŠ” ê·¸ë¦¬ê¸° ì½”ë“œë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤...
            EndPaint(hWnd, &ps);
        }
        break;
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}

// ì •ë³´ ëŒ€í™” ìƒìì˜ ë©”ì‹œì§€ ì²˜ë¦¬ê¸°ì…ë‹ˆë‹¤.
INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    UNREFERENCED_PARAMETER(lParam);
    switch (message)
    {
    case WM_INITDIALOG:
        return (INT_PTR)TRUE;

    case WM_COMMAND:
        if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)
        {
            EndDialog(hDlg, LOWORD(wParam));
            return (INT_PTR)TRUE;
        }
        break;
    }
    return (INT_PTR)FALSE;
}
```

ì´ê²ƒë„ ë„ˆë¬´ ê¸¸ì–´ì„œ ì£¼ì„ìœ¼ë¡œ ëŒ€ì²´

1. **Game**

```cpp
#include "pch.h"
#include "Game.h"
#include "Engine.h"

void Game::Init(const WindowInfo& info)
{
	GEngine->Init(info);
}

void Game::Update()
{
	GEngine->Render();
}
```

ê²Œì„ì—ì„œ ì „ì—­ ë³€ìˆ˜ `GEngine`ì˜ `Init`ì„ ì‹œì‘í•´ì„œ `Engine`ì˜ ì½”ë“œë“¤ êµ¬ë™

`Update`ì—ì„œ `GEngine`ì˜ `Render`ë¡œ `CmdQueue`ì˜ `RenderBegin, RenderEnd`ë¥¼ ì‹¤í–‰í•¨ìœ¼ë¡œì¨ ë§¤ í”„ë ˆì„ë§ˆë‹¤ `RenderBegin, RenderEnd`ì´ ë°˜ë³µëœë‹¤. ìš°ë¦¬ê°€ í™”ë©´ ì„¤ì •í•œ ê²ƒì€ `RenderBegin`ì— ìˆìœ¼ë¯€ë¡œ ì—¬ê¸°ì„œ ìƒ‰ì´ ë‚˜ì˜´.

ê¸°ë³¸ì ì¸ ì¥ì¹˜ ì´ˆê¸°í™”ê°€ ëë‚¬ë‹¤.

---

### ğŸš€ ì¥ì¹˜ ì´ˆê¸°í™”ì˜ ê²°ê³¼

![Result_Device_Rest](../../assets/images/Result_Device_Rest.png)

ì´ê²Œ ê²°ê³¼..


























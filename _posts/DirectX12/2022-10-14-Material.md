---
title: "C++ Rookiss Part2 ê²Œì„ ìˆ˜í•™ê³¼ DirectX12 : Material ë³µìŠµ"

categories:
  - DirectX12
tags:
  - DirectX12

author_profile: false

sidebar:
  nav: "docs"

date: 2022-10-14
last_modified_at: 2022-10-16
---

<br>

### ğŸš€ ê°•ì˜ì— ë“¤ì–´ê°€ê¸° ì•ì„œ ê³ ì¹˜ëŠ” ì 

**í”„ë ˆì„ ë†’ì´ê¸°**

```cpp
BYTE asciiKeys[KEY_TYPE_COUNT] = {};
	if (::GetKeyboardState(asciiKeys) == false)
		return;

	for (uint32 key = 0; key < KEY_TYPE_COUNT; key++)
	{
		// í‚¤ê°€ ëˆŒë ¤ ìˆìœ¼ë©´ true
		if (asciiKeys[key] & 0x80)
		{
			KEY_STATE& state = _states[key];

			// ì´ì „ í”„ë ˆì„ì— í‚¤ë¥¼ ëˆ„ë¥¸ ìƒíƒœë¼ë©´ PRESS
			if (state == KEY_STATE::PRESS || state == KEY_STATE::DOWN)
				state = KEY_STATE::PRESS;
			else
				state = KEY_STATE::DOWN;
		}
		else
		{
			KEY_STATE& state = _states[key];

			// ì´ì „ í”„ë ˆì„ì— í‚¤ë¥¼ ëˆ„ë¥¸ ìƒíƒœë¼ë©´ UP
			if (state == KEY_STATE::PRESS || state == KEY_STATE::DOWN)
				state = KEY_STATE::UP;
			else
				state = KEY_STATE::NONE;
		}
	}
```

í”„ë ˆì„ì´ ë„ˆë¬´ ë‚®ì•„ì„œ ë‹¤ë¥¸ ë°©ë²•ì„ ì‚¬ìš©í•˜ì˜€ë‹¤.  ì´ê²Œ ì™œ ì¢‹ì€ì§€ëŠ” ëª¨ë¦„.

### ğŸš€ ì´ë²ˆ ê°•ì˜ì—ì„œ í•˜ê³ ì‹¶ì€ ê²ƒ

1. shaderì™€ textureë¥¼ í•˜ë‚˜ë¡œ ë¬¶ì€ Materialì„ ë§Œë“¤ê³  ì‹¶ë‹¤.
2. constantBufferë¥¼ ìš©ë„ì— ë§ê²Œ ì—¬ëŸ¬ê°œë¥¼ ë§Œë“¤ê³  ì‹¶ë‹¤.

b1, t0ë¥¼ Materialìš©ë„ë¡œ ì‚¬ìš©í•˜ê¸° ìœ„í•´ì„œ constantBufferë¥¼ ë°°ì—´ë¡œ ë§Œë“¤ ê²ƒì„.
ì‚¬ì „ ì‘ì—…ìœ¼ë¡œ typeê³¼ countí•  enum ìƒì„±

```cpp
enum class CONSTANT_BUFFER_TYPE : uint8
{
	TRANSFORM,
	MATERIAL,
	END
};

enum
{
	CONSTANT_BUFFER_COUNT = static_cast<uint8>(CONSTANT_BUFFER_TYPE::END),
};
```

ê·¸ë¦¬ê³  ë ˆì§€ìŠ¤í„° ë²ˆí˜¸ì— ë”°ë¼ ì—­í• ì´ ë‹¬ë¼ì§€ê¸° ë•Œë¬¸ì— constantbufferì˜ initì˜ ë§¤ê°œë³€ìˆ˜ì— `CBV_REGISTER reg` ë¥¼ ì¶”ê°€í•œë‹¤. ì´ì— ë”°ë¼ CBV_REGISTERëŠ” ë©¤ë²„ë³€ìˆ˜ë¡œ `CBV_REGISTER _reg = {};` ì´ë ‡ê²Œ ë“¤ê³ ìˆê²Œ ëœë‹¤. ë‹¹ì—°íˆ Init ë‚´ë¶€ì—ì„œëŠ” `_reg = reg;`ë¥¼ í•´ì¤˜ì•¼ í•œë‹¤.

pushdataì—ì„œ handleì„ ë½‘ê³  SetCBVsë‚˜ SetSRVë¥¼ í•œë²ˆì— í•˜ê²Œ ë§Œë“¤ì–´ì•¼ ë¨.(ë ˆì§€ìŠ¤í„°ë§ˆë‹¤ ì—­í• ì´ ìƒê²¨ì„œ ì‹¤ìˆ˜ í•  ì—¬ì§€ê°€ ìƒê¸°ë¯€ë¡œ)
pushdataí•¨ìˆ˜ ì†ìœ¼ë¡œ setCbvë¥¼ ë„£ìœ¼ë©´ ëœë‹¤.

ì´ë ‡ê²Œ ë³€ê²½í•˜ë©´ êµ¬ì¡°ê°€ ì™€ì¥ì°½ ë°”ë€Œë¯€ë¡œ ë¹Œë“œë¥¼ í•˜ë©´ ì—ëŸ¬ê°€ ë§‰ ìƒê¸°ëŠ”ë°
í•˜ë‚˜í•˜ë‚˜ ê³ ì¹˜ë©´ ëœë‹¤.

ì²˜ìŒì— Engineì˜ ContantBufferë¥¼ ì‚­ì œë¥¼ í•œë‹¤. ì´ìœ ëŠ” í•˜ë‚˜ë§Œ ì‚¬ìš©í•˜ëŠ”ê²Œ ì•„ë‹ˆë¼ ì—¬ëŸ¬ê°œë¥¼ ì‚¬ìš©í•˜ê¸° ë•Œë¬¸ì´ë‹¤.
ê·¸ì— ë”°ë¼ `CreateContantBuffer` ë¼ëŠ” í•¨ìˆ˜ë¥¼ ë§Œë“ ë‹¤.

```cpp
void Engine::CreateConstantBuffer(CBV_REGISTER reg, uint32 bufferSize, uint32 count)
{
	uint8 typeInt = static_cast<uint8>(reg);
	assert(_constantBuffers.size() == typeInt);

	shared_ptr<ConstantBuffer> buffer = make_shared<ConstantBuffer>();
	buffer->Init(reg, bufferSize, count);
	_constantBuffers.push_back(buffer);
}
```

`vector<shared_ptr<ConstantBuffer>> _constantBuffers;` ì´ë ‡ê²Œ ë©¤ë²„ë³€ìˆ˜ë¡œ ìƒˆë¡œ ë§Œë“¤ê³  Getí•¨ìˆ˜ë„ êµ¬í˜„ í•´ì¤€ë‹¤. í•¨ìˆ˜ ë‚´ë¶€ë¥¼ ë³´ë©´ registerì˜ ë²ˆí˜¸ë¥¼ ë°›ì€ í›„ ì•ˆì „ ì²´í¬, `make_shared<ConstantBuffer>();` ë¡œ ìƒì„±ì„ í•˜ë©´ì„œ ë™ì‹œì— Initê¹Œì§€ í•˜ê³  push_backìœ¼ë¡œ ë°°ì—´ì— ì™ ë„£ëŠ” í•¨ìˆ˜.

ì´ë ‡ê²Œ ì¤€ë¹„ê°€ ëìœ¼ë©´ constantBufferë¥¼ ë§Œë“¤ë ¤ë©´ ì´ì „ì—ëŠ” _cbë¥¼ í†µí•´ì„œ í–ˆì§€ë§Œ ì´ì œëŠ” CreateConsantBufferë¡œ ë ˆì§€ìŠ¤í„°ì— ë”°ë¼ì„œ ë§Œë“¤ì–´ì£¼ë©´ ëœë‹¤. ì´ë²ˆê°•ì˜ì¸ Materialì„ ë§Œë“¤ê¸° ìœ„í•´ì„œ Material í´ë˜ìŠ¤ë¥¼ ë§Œë“ ë‹¤.

```cpp
#pragma once

class Shader;
class Texture;

enum
{
	MATERIAL_INT_COUNT = 5,
	MATERIAL_FLOAT_COUNT = 5,
	MATERIAL_TEXTURE_COUNT = 5,
};

struct MaterialParams
{
	void SetInt(uint8 index, int32 value) { intParams[index] = value; }
	void SetFloat(uint8 index, float value) { floatParams[index] = value; }

	array<int32, MATERIAL_INT_COUNT> intParams;
	array<float, MATERIAL_FLOAT_COUNT> floatParams;
};

class Material
{
public:
	shared_ptr<Shader> GetShader() { return _shader; }

	void SetShader(shared_ptr<Shader> shader) { _shader = shader; }
	void SetInt(uint8 index, int32 value) { _params.SetInt(index, value); }
	void SetFloat(uint8 index, float value) { _params.SetFloat(index, value); }
	void SetTexture(uint8 index, shared_ptr<Texture> texture) { _textures[index] = texture; }

	void Update();

private:
	shared_ptr<Shader>	_shader;
	MaterialParams		_params;
	array<shared_ptr<Texture>, MATERIAL_TEXTURE_COUNT>	_textures;
};
```

êµ¬ì¡°ë¥¼ ë³´ë©´ ìš°ë¦¬ê°€ ì›í•˜ëŠ” shaderì™€ textureë¥¼ í•œ ë¬¶ìŒìœ¼ë¡œ ê´€ë¦¬í•˜ê³  ì‹¶ìœ¼ë‹ˆ ë©¤ë²„ë³€ìˆ˜ë¡œ ë“¤ì–´ê°€ ìˆëŠ” ê²ƒì´ íŠ¹ì§•ì´ë©° ì‹¤ì œë¡œ ì‚¬ìš© í•  ë•Œ í¸í•˜ë ¤ê³  `MaterialParams` êµ¬ì¡°ì²´ë¥¼ ë§Œë“¤ì–´ì¤€ê±¸ ë³¼ ìˆ˜ ìˆë‹¤.

ì—¬ê¸°ì„œ `array`ëŠ” ë²¡í„°ì™€ ë¹„ìŠ·í•˜ì§€ë§Œ ê³ ì •ëœ ë°°ì—´ì´ê³  ë²„ê·¸ë¥¼ ì¡ì„ ë•Œ ìœ ìš©í•œ ì¹œêµ¬ì´ë‹¤.

```cpp
#include "pch.h"
#include "Material.h"
#include "Engine.h"

void Material::Update()
{
	// CBV ì—…ë¡œë“œ
	CONSTANTBUFFER(CONSTANT_BUFFER_TYPE::MATERIAL)->PushData(&_params, sizeof(_params));

	// SRV ì—…ë¡œë“œ
	for (size_t i = 0; i < _textures.size(); i++)
	{
		if (_textures[i] == nullptr)
			continue;

		SRV_REGISTER reg = SRV_REGISTER(static_cast<int8>(SRV_REGISTER::t0) + i);
		GEngine->GetTableDescHeap()->SetSRV(_textures[i]->GetCpuHandle(), reg);
	}

	// íŒŒì´í”„ë¼ì¸ ì„¸íŒ…
	_shader->Update();
}
```

ì—…ë°ì´íŠ¸ í•¨ìˆ˜ì—ì„œ CBV, SRV íŒŒì´í”„ë¼ì¸ ì„¸íŒ…ê¹Œì§€ í•œ í•¨ìˆ˜ì— ë„£ì–´ì„œ ë”°ë¡œë”°ë¡œ ê´€ë¦¬ë¥¼ ì•ˆí•˜ë„ë¡ ë§Œë“¤ì—ˆë‹¤.

```cpp
cbuffer MATERIAL_PARAMS : register(b1)
{
    int int_0;
    int int_1;
    int int_2;
    int int_3;
    int int_4;
    float float_0;
    float float_1;
    float float_2;
    float float_3;
    float float_4;
}

Texture2D tex_0 : register(t0);
Texture2D tex_1 : register(t1);
Texture2D tex_2 : register(t2);
Texture2D tex_3 : register(t3);
Texture2D tex_4 : register(t4);
```

shaderì—ì„œ ë³€ê²½ì‚¬í•­ì´ ìƒê¸°ê³  ë‹¤ì‹œ ë¹Œë“œë¥¼í•˜ê³  ì—ëŸ¬ë¥¼ ì¡ìœ¼ë©´ ë˜ëŠ”ë° Materialì„ ë§Œë“¤ì–´ ì¤¬ì§€ ì‚¬ìš©ì€ ì•ˆí•˜ê³  ìˆìœ¼ë¯€ë¡œ Meshë‚´ë¶€ì— ë“¤ê³  ìˆë„ë¡í•˜ë©´ì„œ renderì—ì„œ ì‚¬ìš©í•˜ë„ë¡ ë§Œë“¤ì—ˆë‹¤.

```cpp
#pragma once

class Material;

class Mesh
{
public:
	void Init(const vector<Vertex>& vertexBuffer, const vector<uint32>& indexBuffer);
	void Render();

	void SetTransform(const Transform& t) { _transform = t; }
	void SetMaterial(shared_ptr<Material> mat) { _mat = mat; }

private:
	void CreateVertexBuffer(const vector<Vertex>& buffer);
	void CreateIndexBuffer(const vector<uint32>& buffer);

private:
	ComPtr<ID3D12Resource>		_vertexBuffer;
	D3D12_VERTEX_BUFFER_VIEW	_vertexBufferView = {};
	uint32						_vertexCount = 0;

	ComPtr<ID3D12Resource>		_indexBuffer;
	D3D12_INDEX_BUFFER_VIEW		_indexBufferView = {};
	uint32						_indexCount = 0;

	Transform _transform = {};
	shared_ptr<Material> _mat = {};
};
```

materialì„ ë“¤ê³  ìˆê³  renderì—ì„œ `_mat->Update();` ë§Œ í•´ì£¼ë©´ ë”°ë¡œë”°ë¡œ í•˜ì§€ ì•Šê³  í•œë²ˆì— ì²˜ë¦¬ ëœë‹¤.
ì½”ë“œë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•´ shaderì—ì„œ `ouput.pos.x += float_0` ì²˜ëŸ¼ í…ŒìŠ¤íŠ¸ ìš©ì„ ì±„ìš°ê³  game.cppì—ì„œ 

```cpp
mesh->Init(vec, indexVec);

shared_ptr<Shader> shader = make_shared<Shader>();
shared_ptr<Texture> texture = make_shared<Texture>();
shader->Init(L"..\\Resources\\Shader\\default.hlsli");
texture->Init(L"..\\Resources\\Texture\\veigar.jpg");

shared_ptr<Material> material = make_shared<Material>();
material->SetShader(shader);
material->SetFloat(0, 0.3f);
material->SetFloat(1, 0.4f);
material->SetFloat(2, 0.3f);
material->SetTexture(0, texture);
mesh->SetMaterial(material);

GEngine->GetCmdQueue()->WaitSync();
```

ì´ëŸ°ì‹ìœ¼ë¡œ ì‚¬ìš©í•˜ê²Œ ëœë‹¤. ë¹Œë“œë¥¼í•˜ê³  ë‹¤ì‹œ ì—ëŸ¬ê°€ ë‚˜ì˜¤ëŠ”ë° ì—¬ê¸°ì„œ ê¸°ì¡´ì— ì‚¬ìš©í–ˆë˜ ë°©ì‹ë“¤ì„ ë‹¤ ì œê±° í•´ì£¼ë©´ ëª¨ë“  ì²˜ë¦¬ê°€ ëë‚œë‹¤.

---

### ğŸš€ ê²°ê³¼ í™”ë©´

![MaterialRet](../../assets/images/MaterialRet.png)

ë³€í•œê±´ ê±°ì˜ ì—†ì§€ë§Œ Materialë¡œ b1ê³¼ t0ì„ ì‚¬ìš©ì„ í•œ ê²ƒ.
---
title: "C++ Rookiss Part2 ê²Œì„ ìˆ˜í•™ê³¼ DirectX12 : ì‚¼ê°í˜• ë„ìš°ê¸° ë³µìŠµ"

categories:
  - DirectX12
tags:
  - DirectX12

author_profile: false

sidebar:
  nav: "docs"

date: 2022-10-04
last_modified_at: 2022-10-14
---

<br>

### ğŸŒ ì‚¼ê°í˜• ë„ìš°ê¸°

1. RootSignature
2. Mesh class
3. Shader class ë° hlsl(hlsli)

ëŒ€ëµì ìœ¼ë¡œ RootSignatureëŠ” ì‚¼ê°í˜• ê·¸ë¦¬ê¸°ë¥¼ í• ê±°ë¼ê³  ê³„ì•½ì„œë¥¼ ë§Œë“œëŠ” ê²ƒ.

MeshëŠ” Vertexë€ ì ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ë¬¼ì²´(ìœ ë‹ˆí‹°ì§±ì˜ ì ë“¤)

ShaderëŠ” ì‹¤ì§ˆì ìœ¼ë¡œ ê·¸ë¦´ ê²ƒë“¤ì¸ë° shader classì—ëŠ” ê°€ë³ê²Œ ì ê³  ì§„ì§œ ê·¸ë¦´ ëª…ë ¹ë“¤ì€ hlslì— ë“¤ì–´ê°€ê²Œ ëœë‹¤.

ì¼ë‹¨ì€ ì½”ë“œ ë³µë¶™í•˜ê³  ë°‘ì— ì½”ë“œ ë¶„ì„ì„ í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ì§„í–‰í•´ë³´ì.

---

### ğŸš€ RootSignature

```cpp
#pragma once

class RootSignature
{
public:
	void Init(ComPtr<ID3D12Device> device);

	ComPtr<ID3D12RootSignature> GetSignature() { return _signature; }

private:
	ComPtr<ID3D12RootSignature>	_signature;
};
```

```cpp
#include "pch.h"
#include "RootSignature.h"

void RootSignature::Init(ComPtr<ID3D12Device> device)
{
	D3D12_ROOT_SIGNATURE_DESC sigDesc = CD3DX12_ROOT_SIGNATURE_DESC(D3D12_DEFAULT);
	sigDesc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT; // ì…ë ¥ ì¡°ë¦½ê¸° ë‹¨ê³„

	ComPtr<ID3DBlob> blobSignature;
	ComPtr<ID3DBlob> blobError;
	::D3D12SerializeRootSignature(&sigDesc, D3D_ROOT_SIGNATURE_VERSION_1, &blobSignature, &blobError);
	device->CreateRootSignature(0, blobSignature->GetBufferPointer(), blobSignature->GetBufferSize(), IID_PPV_ARGS(&_signature));
}
```

---

[https://learn.microsoft.com/ko-kr/windows/win32/direct3d12/example-root-signatures](https://learn.microsoft.com/ko-kr/windows/win32/direct3d12/example-root-signatures)

ë§ˆì†Œ ê³µì‹ë¬¸ì„œë¥¼ ë³´ë©´ `sigDesc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;` ì€ ì…ë ¥ ì¡°ë¦½ê¸° ë‹¨ê³„ë¥¼ ì‚¬ìš©í•œë‹¤ëŠ” ê³„ì•½ì´ê³  ë‚˜ë¨¸ì§€ëŠ” í•˜ëŠ”ê²Œ ì—†ëŠ” ë¹ˆê¹¡í†µì´ë‹¤.

blobë€ Binary Large Objectì˜ ì•½ìë¡œ binary í˜•íƒœë¡œ í° ê°ì²´ë¥¼ ì €ì¥í•œë‹¤.

### ğŸš€ Mesh

```cpp
#pragma once

class Mesh
{
public:
	void Init(vector<Vertex>& vec);
	void Render();

private:
	ComPtr<ID3D12Resource>		_vertexBuffer;
	D3D12_VERTEX_BUFFER_VIEW	_vertexBufferView = {};
	uint32						_vertexCount = 0;
};
```

```cpp
#include "pch.h"
#include "Mesh.h"
#include "Engine.h"

void Mesh::Init(vector<Vertex>& vec)
{
	_vertexCount = static_cast<uint32>(vec.size()); // ì •ì  ê°œìˆ˜
	uint32 bufferSize = _vertexCount * sizeof(Vertex); // ë²„í¼ í¬ê¸°

// ê°€ë³ê²Œ D3D12_HEAP_TYPE_UPLOADë¡œ ì„¤ì •
	D3D12_HEAP_PROPERTIES heapProperty = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	D3D12_RESOURCE_DESC desc = CD3DX12_RESOURCE_DESC::Buffer(bufferSize);

// ì•ìœ¼ë¡œ Resourceë¥¼ ì„¤ì •í•œë‹¤? DEVICE->CreateCommittedResource()
	DEVICE->CreateCommittedResource(
		&heapProperty,
		D3D12_HEAP_FLAG_NONE,
		&desc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&_vertexBuffer));

// Mapìœ¼ë¡œ ì¼ê° ëšœê»‘ ì—´ê¸°
// memcpyë¡œ ì¼ê°ë“¤ ë³µì‚¬
// Unmapìœ¼ë¡œ ì¼ê° ëšœê»‘ ë‹«ê¸°
	void* vertexDataBuffer = nullptr;
	CD3DX12_RANGE readRange(0, 0);
	_vertexBuffer->Map(0, &readRange, &vertexDataBuffer);
	::memcpy(vertexDataBuffer, &vec[0], bufferSize);
	_vertexBuffer->Unmap(0, nullptr);

// GPUìª½ìœ¼ë¡œ ë³µì‚¬ ë˜ì—ˆê¸° ë•Œë¬¸ì— viewë¥¼ í†µí•´ì„œ ì›ê²© ì¡°ì¢…
	_vertexBufferView.BufferLocation = _vertexBuffer->GetGPUVirtualAddress();
	_vertexBufferView.StrideInBytes = sizeof(Vertex);
	_vertexBufferView.SizeInBytes = bufferSize;
}

void Mesh::Render()
{
	CMD_LIST->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
	CMD_LIST->IASetVertexBuffers(0, 1, &_vertexBufferView);
	CMD_LIST->DrawInstanced(_vertexCount, 1, 0, 0);
}
```

---

### ğŸš€ Shader

```cpp
#pragma once

class Shader
{
public:
	void Init(const wstring& path);
	void Update();

private:
	void CreateShader(const wstring& path, const string& name, const string& version, ComPtr<ID3DBlob>& blob, D3D12_SHADER_BYTECODE& shaderByteCode);
	void CreateVertexShader(const wstring& path, const string& name, const string& version);
	void CreatePixelShader(const wstring& path, const string& name, const string& version);

private:
	ComPtr<ID3DBlob>					_vsBlob;
	ComPtr<ID3DBlob>					_psBlob;
	ComPtr<ID3DBlob>					_errBlob;

	ComPtr<ID3D12PipelineState>			_pipelineState;
	D3D12_GRAPHICS_PIPELINE_STATE_DESC	_pipelineDesc = {};
};
```

```cpp
#include "pch.h"
#include "Shader.h"
#include "Engine.h"

void Shader::Init(const wstring& path)
{
	CreateVertexShader(path, "VS_Main", "vs_5_0");
	CreatePixelShader(path, "PS_Main", "ps_5_0");

	D3D12_INPUT_ELEMENT_DESC desc[] =
	{
		{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
		{ "COLOR", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 12, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
		{ "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 28, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
	};

	_pipelineDesc.InputLayout = { desc, _countof(desc) };
	_pipelineDesc.pRootSignature = ROOT_SIGNATURE.Get();

	_pipelineDesc.RasterizerState = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT);
	_pipelineDesc.BlendState = CD3DX12_BLEND_DESC(D3D12_DEFAULT);
	_pipelineDesc.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC(D3D12_DEFAULT);
	_pipelineDesc.SampleMask = UINT_MAX;
	_pipelineDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
	_pipelineDesc.NumRenderTargets = 1;
	_pipelineDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM;
	_pipelineDesc.SampleDesc.Count = 1;

	DEVICE->CreateGraphicsPipelineState(&_pipelineDesc, IID_PPV_ARGS(&_pipelineState));
}

void Shader::Update()
{
	CMD_LIST->SetPipelineState(_pipelineState.Get());
}

void Shader::CreateShader(const wstring& path, const string& name, const string& version, ComPtr<ID3DBlob>& blob, D3D12_SHADER_BYTECODE& shaderByteCode)
{
	uint32 compileFlag = 0;
#ifdef _DEBUG
	compileFlag = D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION;
#endif

	if (FAILED(::D3DCompileFromFile(path.c_str(), nullptr, D3D_COMPILE_STANDARD_FILE_INCLUDE
		, name.c_str(), version.c_str(), compileFlag, 0, &blob, &_errBlob)))
	{
		::MessageBoxA(nullptr, "Shader Create Failed !", nullptr, MB_OK);
	}

	shaderByteCode = { blob->GetBufferPointer(), blob->GetBufferSize() };
}

void Shader::CreateVertexShader(const wstring& path, const string& name, const string& version)
{
	CreateShader(path, name, version, _vsBlob, _pipelineDesc.VS);
}

void Shader::CreatePixelShader(const wstring& path, const string& name, const string& version)
{
	CreateShader(path, name, version, _psBlob, _pipelineDesc.PS);
}
```

---

### ğŸš€ Shader hlsli

```cpp
struct VS_IN
{
    float3 pos : POSITION;
    float4 color : COLOR;
};

struct VS_OUT
{
    float4 pos : SV_Position;
    float4 color : COLOR;
};

VS_OUT VS_Main(VS_IN input)
{
    VS_OUT output = (VS_OUT)0;

    output.pos = float4(input.pos, 1.f);
    output.color = input.color;

    return output;
}

float4 PS_Main(VS_OUT input) : SV_Target
{
    return input.color;
}
```

---

### ğŸš€ ê·¸ ì™¸ ë³€ê²½ì‚¬í•­ ë° ì‚¬ìš©

```cpp
shared_ptr<Mesh> mesh = make_shared<Mesh>();
shared_ptr<Shader> shader = make_shared<Shader>();

void Game::Init(const WindowInfo& info)
{
	GEngine->Init(info);

	vector<Vertex> vec(3);
	vec[0].pos = Vec3(0.f, 0.5f, 0.5f);
	vec[0].color = Vec4(1.f, 0.f, 0.f, 1.f);
	vec[1].pos = Vec3(0.5f, -0.5f, 0.5f);
	vec[1].color = Vec4(0.f, 1.f, 0.f, 1.f);
	vec[2].pos = Vec3(-0.5f, -0.5f, 0.5f);
	vec[2].color = Vec4(0.f, 0.f, 1.f, 1.f);

	mesh->Init(vec);

	shader->Init(L"..\\Resources\\Shader\\default.hlsli");

	GEngine->GetCmdQueue()->WaitSync();
}

void Game::Update()
{
	GEngine->RenderBegin();

	shader->Update();
	mesh->Render();

	GEngine->RenderEnd();
}
```

`Engine`ì—ì„œ ë©¤ë²„ë³€ìˆ˜ë¡œ `RootSignature`ë¥¼ ë„£ì–´ì£¼ê³  `Get`í•¨ìˆ˜ë¡œ ë¹¼ì˜¬ ìˆ˜ ìˆê²Œ ë§Œë“¤ì—ˆê³ 

`#define`ì„ ì‚¬ìš©í•´ì„œ ë§¤í¬ë¡œ í•¨ìˆ˜ë¡œ `ROOT_SIGNATURE`ë¥¼ ë” ì‰½ê²Œ ëº„ ìˆ˜ ìˆê²Œ ë§Œë“¤ì—ˆë‹¤.

---

### ğŸš€ ê²°ê³¼ë¬¼

![makeTriangle](../../assets/images/makeTriangle.png)

`Vertex` 3ê°œë¥¼ ë§Œë“¤ê³  ê° ìœ„ì¹˜ì™€ ìƒ‰ì„ ì •í•œ ë’¤ `shader`, `mesh`ë¥¼ í†µí•´ì„œ ê·¸ë¦¬ê¸°
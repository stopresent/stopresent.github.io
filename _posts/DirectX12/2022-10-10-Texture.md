---
title: "C++ Rookiss Part2 ê²Œì„ ìˆ˜í•™ê³¼ DirectX12 : Texture ë³µìŠµ"

categories:
  - DirectX12
tags:
  - DirectX12

author_profile: false

sidebar:
  nav: "docs"

date: 2022-10-10
last_modified_at: 2022-10-15
---

<br>

### ğŸš€ ë¬´ì—‡ì„ í•  ê²ƒì¸ê°€?

ì „ ì‹œê°„ì—ì„œ ë§Œë“  ì‚¬ê°í˜•ì˜ vertexì— uvì¢Œí‘œë¥¼ ë„£ì–´ì„œ ì‚¬ì§„ì„ ì‚½ì… í•  ê²ƒì´ë‹¤.

ì•„ ì§„ì§œ ë„ˆë¬´ ì–´ë ¤ìš´ë° ëª»í•´ë¨¹ê² ëŠ”ë° ì•„

ì•„ã…ã…‡

ì•„ã…ì•™

ã…ì•„ì•„ì•„ì•„ì•„ì•„ã…ì•„ì•„ì•„ì•„ ë¨¸ë¦¬ê°€ í„°ì§ˆê±°ê°™ì€ë° ëª¨ë¥´ê² ëŠ”ë°..! 

![textureChanges](../../assets/images/textureChanges.png)

```cpp
#include <DirectXTex/DirectXTex.h>
#include <DirectXTex/DirectXTex.inl>

#ifdef _DEBUG
#pragma comment(lib, "DirectXTex\\DirectXTex_debug.lib")
#else
#pragma comment(lib, "DirectXTex\\DirectXTex.lib")
#endif
```

ì—”ì§„ì˜ ëŒ€ë¶€ë¶„ì´ ë³€ê²½ ë˜ì—ˆë‹¤. Resourceì‚°í•˜ì˜ Texture classê°€ ì¶”ê°€ ë˜ì—ˆê³ , ë§ˆì†Œì˜ ê³µì‹ ë°ì´í„°ì¸ `DirecteXTex.h` `DirecteXTex.inl` `DirecteXTex.lib` ì„ ë‹¤ìš´ ë°›ê³  ì†”ë£¨ì…˜ íŒŒì¼ì—ì„œ Libraryí´ë”ë¥¼ ë§Œë“¤ì–´ì„œ ê´€ë¦¬í•˜ê²Œ ëœë‹¤.

í—¤ë”íŒŒì¼ : Library\Include
libíŒŒì¼ : Library\Lib

```cpp
#include <filesystem>
namespace fs = std::filesystem;
```

íŒŒì¼ì„ ê´€ë¦¬í•˜ê¸° ìœ„í•œ í—¤ë”íŒŒì¼ì´ C++17 ë¶€í„° ì¶”ê°€ ë˜ì—ˆê¸° ë•Œë¬¸ì— ì–¸ì–´ë¥¼ 17ë¡œ ë§ì¶˜ í›„ `EnginePch.h` ì— filesystemì„ ì¶”ê°€í•œë‹¤. filesystemì˜ byteì™€ stdì˜ byteê°€ ì¶©ëŒ í•˜ê¸° ë•Œë¬¸ì— `#define _HAS_STD_BYTE NULL` ì„ ì¶”ê°€ í•´ì•¼í•œë‹¤.

---

### ğŸš€ Texture

```cpp
#pragma once

class Texture
{
public:
	void Init(const wstring& path);

	D3D12_CPU_DESCRIPTOR_HANDLE GetCpuHandle() { return _srvHandle; }

public:
	void CreateTexture(const wstring& path);
	void CreateView();

private:
	ScratchImage			 		_image;
	ComPtr<ID3D12Resource>			_tex2D;

	ComPtr<ID3D12DescriptorHeap>	_srvHeap;
	D3D12_CPU_DESCRIPTOR_HANDLE		_srvHandle;
};
```

```cpp
void Texture::CreateTexture(const wstring& path)
{
	// íŒŒì¼ í™•ì¥ì ì–»ê¸°
	wstring ext = fs::path(path).extension();

	if (ext == L".dds" || ext == L".DDS")
		::LoadFromDDSFile(path.c_str(), DDS_FLAGS_NONE, nullptr, _image);
	else if (ext == L".tga" || ext == L".TGA")
		::LoadFromTGAFile(path.c_str(), nullptr, _image);
	else // png, jpg, jpeg, bmp
		::LoadFromWICFile(path.c_str(), WIC_FLAGS_NONE, nullptr, _image);

	HRESULT hr = ::CreateTexture(DEVICE.Get(), _image.GetMetadata(), &_tex2D);
	assert(SUCCEEDED(hr));

	vector<D3D12_SUBRESOURCE_DATA> subResources;

	hr = ::PrepareUpload(DEVICE.Get(),
		_image.GetImages(),
		_image.GetImageCount(),
		_image.GetMetadata(),
		subResources);

	assert(SUCCEEDED(hr));

	const uint64 bufferSize = ::GetRequiredIntermediateSize(_tex2D.Get(), 0, static_cast<uint32>(subResources.size()));

	D3D12_HEAP_PROPERTIES heapProperty = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	D3D12_RESOURCE_DESC desc = CD3DX12_RESOURCE_DESC::Buffer(bufferSize);

	ComPtr<ID3D12Resource> textureUploadHeap;
	hr = DEVICE->CreateCommittedResource(
		&heapProperty,
		D3D12_HEAP_FLAG_NONE,
		&desc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(textureUploadHeap.GetAddressOf()));

	assert(SUCCEEDED(hr));

	::UpdateSubresources(RESOURCE_CMD_LIST.Get(),
		_tex2D.Get(),
		textureUploadHeap.Get(),
		0, 0,
		static_cast<unsigned int>(subResources.size()),
		subResources.data());

	GEngine->GetCmdQueue()->FlushResourceCommandQueue();
}
```

íŒŒì¼ í™•ì¥ìëŠ” filesystemì„ ì´ìš©í•œ ê²ƒì´ë¯€ë¡œ ì•ì„œ `#include <filesystem>` ì„ ë§í•˜ëŠ” ê²ƒì´ë‹¤. í™•ì¥ìë¥¼ ë½‘ì•„ì™€ì„œ `ScratchImage _image` ì— ëŒ€ì…, `CreateTexture` ë¡œ í…ìŠ¤ì³ë¥¼ ë§Œë“¤ì–´ì¤€ë‹¤.

ì§„ì§œ ë­” ë§ì¸ì§€ í•˜ë‚˜ë„ ëª¨ë¥´ê² ëŠ”ë°ìš©?

```cpp
void Texture::CreateView()
{
	D3D12_DESCRIPTOR_HEAP_DESC srvHeapDesc = {};
	srvHeapDesc.NumDescriptors = 1;
	srvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
	srvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
	DEVICE->CreateDescriptorHeap(&srvHeapDesc, IID_PPV_ARGS(&_srvHeap));

	_srvHandle = _srvHeap->GetCPUDescriptorHandleForHeapStart();

	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {};
	srvDesc.Format = _image.GetMetadata().format;
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.Texture2D.MipLevels = 1;
	DEVICE->CreateShaderResourceView(_tex2D.Get(), &srvDesc, _srvHandle);
}
```

`CreateDescriptorHeap` ì„ í•˜ê¸° ìœ„í•œ desc ì±„ì›Œì£¼ê¸°, `GetCPUDescriptorHandleForHeapStart` ë¡œ ì‹œì‘ ìœ„ì¹˜ `_srvHanlde` ì— ë„£ê¸°, ìµœì¢…ì ìœ¼ë¡œ `CreateShaderResourceView` ë¡œ view ìƒì„±

```cpp
void Texture::Init(const wstring& path)
{
	CreateTexture(path);
	CreateView();
}
```

ì´ˆê¸°í™” í•¨ìˆ˜ëŠ” `CreateTexture` ì™€ `CreateView` ë¡œ êµ¬ì„±

---

### ğŸš€ Command Queue

ë¦¬ì†ŒìŠ¤ë¥¼ ë¡œë“œí•˜ëŠ” ìš©ë„ë¡œ cmdlistë¥¼ ìƒˆë¡œ ë§Œë“¤ì–´ ì¤„ ê²ƒì´ë‹¤.

```cpp
ComPtr<ID3D12CommandAllocator>		_resCmdAlloc;
ComPtr<ID3D12GraphicsCommandList>	_resCmdList;
```

CommandQueue classì— ì¶”ê°€ í•´ì£¼ì—ˆë‹¤.

`ComPtr<ID3D12GraphicsCommandList> GetResourceCmdList() { return _resCmdList; }` ë¦¬ì†ŒìŠ¤ cmdlistë¥¼ ëº´ì˜¤ëŠ” í•¨ìˆ˜ë„ ì¶”ê°€ ëë‹¤.

```cpp
void CommandQueue::Init(ComPtr<ID3D12Device> device, shared_ptr<class SwapChain> swapChain)
{
	_swapChain = swapChain;

	D3D12_COMMAND_QUEUE_DESC queueDesc = {};
	queueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;
	queueDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;

	device->CreateCommandQueue(&queueDesc, IID_PPV_ARGS(&_cmdQueue));
	device->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&_cmdAlloc));
	device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, _cmdAlloc.Get(), nullptr, IID_PPV_ARGS(&_cmdList));
	_cmdList->Close();

	device->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&_resCmdAlloc)); // new!!
	device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, _resCmdAlloc.Get(), nullptr, IID_PPV_ARGS(&_resCmdList)); // new!!

	device->CreateFence(_fenceValue, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&_fence));
	_fenceEvent = ::CreateEvent(nullptr, FALSE, FALSE, nullptr);
}
```

ì´ˆê¸°í™” í•¨ìˆ˜ì— ìƒˆë¡œìš´ ì¸ìë“¤ì„ `CreateCommandAllocator` `CreateCommandList` ë¡œ ì¶”ê°€ í•´ì£¼ì—ˆë‹¤.

ê¸°ì¡´ì˜ cmdlistê°€ closeê°€ ë˜ë”ë¼ë„ ì‚¬ìš©ê°€ëŠ¥í•˜ë‹¤. ì™œëƒí•˜ë©´ ìƒˆë¡œìš´ cmdlistì´ê¸° ë•Œë¬¸ì´ë‹¤.

`void FlushResourceCommandQueue();` ì— ë¦¬ì†ŒìŠ¤ cmdlistì˜ ì¼ê°ì„ ë°€ì–´ë„£ê³  ìƒˆë¡œìš´ ì¼ê°ì„ ë°›ì„ ìˆ˜ ìˆëŠ” ìƒíƒœë¥¼ ë§Œë“œëŠ” í•¨ìˆ˜ë¥¼ ë§Œë“ ë‹¤.

```cpp
void CommandQueue::FlushResourceCommandQueue()
{
	_resCmdList->Close();

	ID3D12CommandList* cmdListArr[] = { _resCmdList.Get() };
	_cmdQueue->ExecuteCommandLists(_countof(cmdListArr), cmdListArr);

	WaitSync();

	_resCmdAlloc->Reset();
	_resCmdList->Reset(_resCmdAlloc.Get(), nullptr);
}
```

í•¨ìˆ˜ë¥¼ ë³´ë©´ ì¼ê°ì˜ ë¬¸ì„ ë‹«ì€ í›„ ì‹¤ì œ ì¼ê°ì„ `ExecuteCommandLists` ë¡œ ì‹¤í–‰ì‹œí‚¤ê³  `WaitSync` ë¡œ ë™ê¸°í™”ë¥¼ í•˜ë©´ì„œ resetì„ í•˜ë©° ë‹¤ìŒ ì¼ê°ì„ ë°›ì„ ì¤€ë¹„ë¥¼ í•´ì£¼ëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆë‹¤.

---

### ğŸš€ RootSignature

```cpp
#pragma once

class RootSignature
{
public:
	void Init();

	ComPtr<ID3D12RootSignature> GetSignature() { return _signature; }

private:
	void CreateSamplerDesc(); // new!!
	void CreateRootSignature(); // new!!

private:
	ComPtr<ID3D12RootSignature>	_signature;
	D3D12_STATIC_SAMPLER_DESC _samplerDesc; // new!!
};
```

shaderì—ì„œ ì‚¬ìš©í•  `D3D12_STATIC_SAMPLER_DESC` ì´ ì¶”ê°€ ë˜ì—ˆìœ¼ë©° ì´ˆê¸°í™” í•¨ìˆ˜ë¥¼ ë¶„ë¦¬í•˜ê¸° ìœ„í•´ì„œ 

`CreateSamplerDesc` ì™€ `CreateRootSignature` ë¡œ ë‚˜ë‰˜ê²Œ ë˜ì—ˆë‹¤.

```cpp
#include "pch.h"
#include "RootSignature.h"
#include "Engine.h"

void RootSignature::Init()
{
	CreateSamplerDesc();
	CreateRootSignature();
}

void RootSignature::CreateRootSignature()
{
	CD3DX12_DESCRIPTOR_RANGE ranges[] =
	{
		CD3DX12_DESCRIPTOR_RANGE(D3D12_DESCRIPTOR_RANGE_TYPE_CBV, CBV_REGISTER_COUNT, 0), // b0~b4
		CD3DX12_DESCRIPTOR_RANGE(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, SRV_REGISTER_COUNT, 0), // t0~t4 new!!
	};

	CD3DX12_ROOT_PARAMETER param[1];
	param[0].InitAsDescriptorTable(_countof(ranges), ranges);

	D3D12_ROOT_SIGNATURE_DESC sigDesc = CD3DX12_ROOT_SIGNATURE_DESC(_countof(param), param, 1, &_samplerDesc);

	sigDesc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT; // ì…ë ¥ ì¡°ë¦½ê¸° ë‹¨ê³„

	ComPtr<ID3DBlob> blobSignature;
	ComPtr<ID3DBlob> blobError;
	::D3D12SerializeRootSignature(&sigDesc, D3D_ROOT_SIGNATURE_VERSION_1, &blobSignature, &blobError);
	DEVICE->CreateRootSignature(0, blobSignature->GetBufferPointer(), blobSignature->GetBufferSize(), IID_PPV_ARGS(&_signature));
}

void RootSignature::CreateSamplerDesc()
{
	_samplerDesc = CD3DX12_STATIC_SAMPLER_DESC(0);
}
```

`CreateRootSignature` ì—ì„œ SRVë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•´ `CD3DX12_DESCRIPTOR_RANGE` ë¥¼ ì¶”ê°€ í–ˆë‹¤. 

---

### ğŸš€ Shader

```cpp
cbuffer TEST_B0 :register(b0)
{
    float4 offset0;
}

cbuffer TEST_B1 : register(b1)
{
    float4 offset1;
}

Texture2D tex_0 : register(t0); // new!!
SamplerState sam_0 : register(s0); // new!!

struct VS_IN
{
    float3 pos : POSITION;
    float4 color : COLOR;
    float2 uv : TEXCOORD; // new!!
};

struct VS_OUT
{
    float4 pos : SV_Position;
    float4 color : COLOR;
    float2 uv : TEXCOORD; // new!!
};

VS_OUT VS_Main(VS_IN input)
{
    VS_OUT output = (VS_OUT)0;

    output.pos = float4(input.pos, 1.f);
    output.color = input.color;
    output.uv = input.uv; // new!!

    return output;
}

float4 PS_Main(VS_OUT input) : SV_Target
{
    float4 color = tex_0.Sample(sam_0, input.uv); // new!!
    return color;
}
```

ì§€ê¸ˆ ë‹¨ê³„ì—ì„œ ë°°ìš°ëŠ” ê²ƒì´ ì•„ë‹ˆì§€ë§Œ í•„ìš”í•˜ê¸° ë•Œë¬¸ì— ì“°ëŠ” ê²ƒë“¤

```cpp
void Shader::Init(const wstring& path)
{
	CreateVertexShader(path, "VS_Main", "vs_5_0");
	CreatePixelShader(path, "PS_Main", "ps_5_0");

	D3D12_INPUT_ELEMENT_DESC desc[] =
	{
		{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
		{ "COLOR", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 12, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
		{ "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 28, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 }, // new!!
	};

	_pipelineDesc.InputLayout = { desc, _countof(desc) };
	_pipelineDesc.pRootSignature = ROOT_SIGNATURE.Get();

	_pipelineDesc.RasterizerState = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT);
	_pipelineDesc.BlendState = CD3DX12_BLEND_DESC(D3D12_DEFAULT);
	_pipelineDesc.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC(D3D12_DEFAULT);
	_pipelineDesc.SampleMask = UINT_MAX;
	_pipelineDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
	_pipelineDesc.NumRenderTargets = 1;
	_pipelineDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM;
	_pipelineDesc.SampleDesc.Count = 1;

	DEVICE->CreateGraphicsPipelineState(&_pipelineDesc, IID_PPV_ARGS(&_pipelineState));
}
```

textureë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•´ì„œ shader initì—ì„œ `TEXCOORD` ê°€ ì¶”ê°€ ë˜ì—ˆë‹¤. ì´í•˜ ë™ì¼

---

### ğŸš€ ì‚¬ìš©í•´ë³´ê¸°

```cpp
vector<Vertex> vec(4);
vec[0].pos = Vec3(-0.5f, 0.5f, 0.5f);
vec[0].color = Vec4(1.f, 0.f, 0.f, 1.f);
vec[0].uv = Vec2(0.f, 0.f);
vec[1].pos = Vec3(0.5f, 0.5f, 0.5f);
vec[1].color = Vec4(0.f, 1.f, 0.f, 1.f);
vec[1].uv = Vec2(1.f, 0.f);
vec[2].pos = Vec3(0.5f, -0.5f, 0.5f);
vec[2].color = Vec4(0.f, 0.f, 1.f, 1.f);
vec[2].uv = Vec2(1.f, 1.f);
vec[3].pos = Vec3(-0.5f, -0.5f, 0.5f);
vec[3].color = Vec4(0.f, 1.f, 0.f, 1.f);
vec[3].uv = Vec2(0.f, 1.f);
```

uv ì¢Œí‘œë¥¼ ì¶”ê°€ í•´ì¤€ `vector<Vertex> vec(4);` ë¥¼ ë§Œë“¤ì—ˆê³  textureë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•´ì„œ ê°„ì˜ë¡œ meshì— tetureë¥¼ í¬í•¨í•˜ë„ë¡ í•œë‹¤.

```cpp
#pragma once

class Texture; // new!!

class Mesh
{
public:
	void Init(const vector<Vertex>& vertexBuffer, const vector<uint32>& indexBuffer);
	void Render();

	void SetTransform(const Transform& t) { _transform = t; }
	void SetTexture(shared_ptr<Texture> tex) { _tex = tex; } // new!!

private:
	void CreateVertexBuffer(const vector<Vertex>& buffer);
	void CreateIndexBuffer(const vector<uint32>& buffer);

private:
	ComPtr<ID3D12Resource>		_vertexBuffer;
	D3D12_VERTEX_BUFFER_VIEW	_vertexBufferView = {};
	uint32						_vertexCount = 0;

	ComPtr<ID3D12Resource>		_indexBuffer;
	D3D12_INDEX_BUFFER_VIEW		_indexBufferView = {};
	uint32						_indexCount = 0;

	Transform _transform = {};
	shared_ptr<Texture> _tex = {}; // new!! 
};
```

textureë¥¼ ë°›ì„ ê·¸ë¦‡ì„ ë§Œë“¤ì—ˆë‹¤.

```cpp
shader->Init(L"..\\Resources\\Shader\\default.hlsli");

texture->Init(L"..\\Resources\\Texture\\veigar.jpg");
```

ë¡œ game.cppì—ì„œ textureë¥¼ ìƒì„±í•œ í›„ ì— initê¹Œì§€ í•´ì£¼ì—ˆë‹¤. 

ì´ textureë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•´ì„œ ìœ„ì—ì„œ ê°„ì˜ë¡œ ë§Œë“  `SetTexture` ë¥¼ ì‚¬ìš©í•˜ê²Œ ë˜ëŠ”ë° 

```cpp
void Game::Update()
{
	GEngine->RenderBegin();

	shader->Update();

	{
		Transform t;
		t.offset = Vec4(0.f, 0.f, 0.f, 0.f);
		mesh->SetTransform(t);

		mesh->SetTexture(texture); // new!!
		mesh->Render();
	}

	GEngine->RenderEnd();
}
```

ì´ë ‡ê²Œ SetTextureë¥¼ ë§µí•‘í•  ìˆ˜ ìˆë‹¤.

 meshì˜ renderì—ì„œ `GEngine->GetTableDescHeap()->SetSRV(_tex->GetCpuHandle(), SRV_REGISTER::t0);` ê°€ ì¶”ê°€ ë˜ëŠ”ë° `SetSRV` ì´ í•µì‹¬ì´ë‹¤. `SetSRV` ì„ ì‚¬ìš©í•˜ê¸° ìœ„í•´ì„œ tableDescriptorHeapì„ ë³€ê²½í•´ì•¼ í•œë‹¤.

```cpp
#pragma once

class TableDescriptorHeap
{
public:
	void Init(uint32 count);

	void Clear();
	void SetCBV(D3D12_CPU_DESCRIPTOR_HANDLE srcHandle, CBV_REGISTER reg);
	void SetSRV(D3D12_CPU_DESCRIPTOR_HANDLE srcHandle, SRV_REGISTER reg); // new!!

	void CommitTable();

	ComPtr<ID3D12DescriptorHeap> GetDescriptorHeap() { return _descHeap; }

	D3D12_CPU_DESCRIPTOR_HANDLE GetCPUHandle(CBV_REGISTER reg);
	D3D12_CPU_DESCRIPTOR_HANDLE GetCPUHandle(SRV_REGISTER reg); // new!!

private:
	D3D12_CPU_DESCRIPTOR_HANDLE GetCPUHandle(uint8 reg);

private:

	ComPtr<ID3D12DescriptorHeap>	_descHeap;
	uint64							_handleSize = 0;
	uint64							_groupSize = 0;
	uint64							_groupCount = 0;

	uint32							_currentGroupIndex = 0;
};
```

`SRV_REGISTER` `CBV_REGISTER` ì„ uint8ë¡œ ì„¸íŒ…í•´ì„œ `GetCPUHandle` ì˜ ë§¤ê°œë³€ìˆ˜ê°€ uint8ë¡œ ë³€ê²½ ë˜ì—ˆê³ , `void SetSRV(D3D12_CPU_DESCRIPTOR_HANDLE srcHandle, SRV_REGISTER reg);` ì´ ì¶”ê°€ ë˜ì—ˆë‹¤.

```cpp
void TableDescriptorHeap::SetSRV(D3D12_CPU_DESCRIPTOR_HANDLE srcHandle, SRV_REGISTER reg)
{
	D3D12_CPU_DESCRIPTOR_HANDLE destHandle = GetCPUHandle(reg);

	uint32 destRange = 1;
	uint32 srcRange = 1;
	DEVICE->CopyDescriptors(1, &destHandle, &destRange, 1, &srcHandle, &srcRange, D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
}
```

`SetSRV` ì—­ì‹œ `SetCBV` ì²˜ëŸ¼ descriptorë¥¼ ë³µì‚¬í•˜ëŠ” ì—­í• ì„ í•˜ëŠ” í•¨ìˆ˜ì´ë‹¤. 

ì—¬ê¸°ê¹Œì§€ í•´ì£¼ë©´ meshâ†’renderì—ì„œ setSRVê¹Œì§€ ì™„ë£Œê°€ ë˜ë¯€ë¡œ textureê°€ ì…íˆê²Œ ëœë‹¤.

---

### ğŸš€ ê²°ê³¼ í™”ë©´

![textureRet](../../assets/images/textureRet.png)

textureë¥¼ ë¡œë“œí•˜ê³  ê·¸ì— ë§ì¶°ì„œ rootSignature, shader, mesh, commandQueue ë“±ë“±ì´ ë³€ê²½ ë˜ì—ˆìœ¼ë©° uvì¢Œí‘œë¥¼ ì„¤ì •í•˜ì—¬ vertexì˜ ì ì— ë§ì¶° textureMappingì´ ì´ë£¨ì–´ ì¡Œë‹¤.

![textureRet2](../../assets/images/textureRet2.png)

`vec[0].pos = Vec3(-0.5f, 0.5f, 0.5f);` ì—ì„œ `vec[0].pos = Vec3(-1.f, 0.5f, 0.5f);` ë¡œ ë³€ê²½ëœ ëª¨ìŠµ. uvì¢Œí‘œê³„ê°€ ì˜ ì‘ë™í•˜ê³  ìˆêµ°!